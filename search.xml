<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI大模型学习之Python基础</title>
    <url>/2024/07/05/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8BPython%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-HelloWorld</title>
    <url>/2023/10/21/Java%E5%9F%BA%E7%A1%80-HelloWorld/</url>
    <content><![CDATA[<p>HelloWorld</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//class:是类的意思，关键字</span><br><span class="line">//HelloWorld:是类名，是自己起的名字，都是标识符</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">	/*</span><br><span class="line">	1,public : 访问修饰符 </span><br><span class="line">	2，static: 静态的意思</span><br><span class="line">	3，void :表示这个方法没有返回值</span><br><span class="line">	4，main: 表示方法名，而且是特殊的，主方法，	</span><br><span class="line">	5,String[] args:方法的参数列表，[]是数组的意思；（）方法的标识</span><br><span class="line">	*/</span><br><span class="line">	public static void main(String[] args)&#123;//main方法是程序的入口</span><br><span class="line">		//打印双引号里面的内容</span><br><span class="line">		//System.out.println:打印，之后换行</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,Java&quot;</span>);</span><br><span class="line">		//System.out.print:打印，之后不换行</span><br><span class="line">		System.out.print(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;world!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔记：<a href="https://www.yuque.com/books/share/a1b9ed08-c795-438c-8c9e-260573fae4f2#">https://www.yuque.com/books/share/a1b9ed08-c795-438c-8c9e-260573fae4f2?#</a> </p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>GC插件</title>
    <url>/2022/02/22/GC%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>JDC自带的调优诊断工具Visualvm</p>
<span id="more"></span>
<p>启动cmd输入jvisualvm启动工具</p>
<p><img src="/images/gc%E5%B7%A5%E5%85%B7.png"><br>给jdk自带的jvisualvm安装Visual GC插件，遇到We’re sorry the java.net site has<br>closed（我们很抱歉java.net网站已经关闭）<br>1、找到新的更新地址<br>visualvm新访问地址：<a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p>
<p><img src="/images/gc%E6%8F%92%E4%BB%B6.png"><br>进入jvisualvm的插件管理”工具” - “插件”<br>在”设置”中修改url地址为刚才我们在github上找到的对应我们JDK版本的地址，修改成功后，可用插件即可刷新出来，重启即可看到VisualGC</p>
<p>一：整个区域分为三部分：spaces、graphs、histogram<br>1，spaces区域：代表虚拟机内存分布情况。从图中可以看出，虚拟机被分为Perm、<br>Old、Eden、S0、S1<br>注意：如果对每个区域基本概念不是很熟悉的可以先了解下java虚拟机运行时数据区这篇<br>文字。<br>1.1）perm：英文叫做Permanent Generation，我们称之为永久代。(根据深入java虚拟<br>机作者说明，这里说法不是不是很正确，因为hotspot虚拟机的设计团队选择把GC分代收<br>集扩展至此而已，正确的应该叫做方法区或者非堆)。<br>1.1.1）通过VM Args:-XX:PermSize=128m -XX:MaxPermSize=256m 设置初始值与最<br>大值<br>1.2）heap：java堆(java heap)。它包括老年代(图中Old区域)和新生代(图中Eden/S0/S1<br>三个统称新生代，分为Eden区和两个Survivor区域)，他们默认是8:1分配内存<br>1.2.1）通过VM Args:-xms512m -Xmx512m -XX:+HeapDumpOnOutofMemoryError<br>-Xmn100m -XX:SurvivorRatio=8 设置初始堆内存、最大堆内存、内存异常打印dump、<br>新生代内存、新生代内存分配比例(8:1:1)，因为Heap分为新生代跟老年代，所以512M100M=412M，老年代就是412M(初始内存跟最大内存最好相等，防止内存不够时扩充内<br>存或者Full GC，导致性能降低)<br>2，Graphs区域：内存使用详细介绍<br>2.1）Compile Time(编译时间)：6368compiles 表示编译总数，4.407s表示编译累计<br>时间。一个脉冲表示一次JIT编译，窄脉冲表示持续时间短，宽脉冲表示持续时间长。<br>2.2）Class Loader Time(类加载时间): 20869loaded表示加载类数量, 139 unloaded<br>表示卸载的类数量，40.630s表示类加载花费的时间<br>2.3）GC Time(GC Time)：2392collections表示垃圾收集的总次数，37.454s表示垃圾<br>收集花费的时间，last cause表示最近垃圾收集的原因<br>2.4）Eden Space(Eden 区)：括号内的31.500M表示最大容量，9.750M表示当前容<br>量，后面的4.362M表示当前使用情况，2313collections表示垃圾收集次数，8.458s表示垃<br>圾收集花费时间<br>2.5）Survivor 0/Survivor 1(S0和S1区)：括号内的3.938M表示最大容量，1.188M表示<br>当前容量，之后的值是当前使用情况<br>2.6）Old Gen(老年代)：括号内的472.625M表示最大容量，145.031M表示当前容量，<br>之后的87.031表示当前使用情况，79collections表示垃圾收集次数 ，28.996s表示垃圾收<br>集花费时间<br>2.7）Perm Gen(永久代)：括号内的256.000M表示最大容量，105.250M表示当前容<br>量，之后的105.032M表示当前使用情况<br>3，Histogram区域：survivor区域参数跟年龄柱状图<br>3.1）Tenuring Threshold：表示新生代年龄大于当前值则进入老年代<br>3.2）Max Tenuring Threshold：表示新生代最大年龄值。<br>3.3）Tenuring Threshold与Max Tenuring Threshold区别：Max Tenuring<br>Threshold是一个最大限定，所有的新生代年龄都不能超过当前值，而Tenuring<br>Threshold是个动态计算出来的临时值，一般情况与Max Tenuring Threshold相等，如果<br>在Suivivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或<br>者等于该年龄的对象就都可以直接进入老年代(如果计算出来年龄段是5，则Tenuring<br>Threshold=5，age&gt;=5的Suivivor对象都符合要求)，它才是新生代是否进入老年代判断的<br>依据。<br>3.4）Desired Survivor Size：Survivor空间大小验证阙值(默认是survivor空间的一<br>半)，用于Tenuring Threshold判断对象是否提前进入老年代。<br>3.5）Current Survivor Size：当前survivor空间大小<br>3.6）histogram柱状图：表示年龄段对象的存储柱状图<br>3.7）如果显示指定-XX:+UseParallelGC –新生代并行、老年代串行收集器 ，则<br>histogram柱状图不支持当前收集器</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Expalin详解与索引最佳实践</title>
    <url>/2022/04/25/Expalin%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>explain详解与索引最佳实践<br>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈；</p>
<span id="more"></span>

<p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL；</p>
<p>注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中；</p>
<h1 id="演员表"><a href="#演员表" class="headerlink" title="演员表"></a>演员表</h1><p>DROP TABLE IF EXISTS <code>actor</code>;<br>CREATE TABLE <code>actor</code> (<br>    <code>id</code> int(11) NOT NULL,<br>    <code>name</code> varchar(45) DEFAULT NULL,<br>    <code>update_time</code> datetime DEFAULT NULL,<br>    PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>INSERT INTO <code>actor</code> (<code>id</code>, <code>name</code>, <code>update_time</code>) VALUES (1,’a’,’2017-12-2 15:27:18’), (2,’b’,’2017-12-22 15:27:18’), (3,’c’,’2017-12-22 15:27:18’);</p>
<h1 id="电影表"><a href="#电影表" class="headerlink" title="电影表"></a>电影表</h1><p>DROP TABLE IF EXISTS <code>film</code>;<br>CREATE TABLE <code>film</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>    <code>name</code> varchar(10) DEFAULT NULL,<br>    PRIMARY KEY (<code>id</code>),<br>    KEY <code>idx_name</code> (<code>name</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>INSERT INTO <code>film</code> (<code>id</code>, <code>name</code>) VALUES (3,’film0’),(1,’film1’),(2,’film2’);</p>
<h1 id="演员和电影的关联表"><a href="#演员和电影的关联表" class="headerlink" title="演员和电影的关联表"></a>演员和电影的关联表</h1><p>DROP TABLE IF EXISTS <code>film_actor</code>;<br>CREATE TABLE <code>film_actor</code> (<br>    <code>id</code> int(11) NOT NULL,<br>    <code>film_id</code> int(11) NOT NULL,<br>    <code>actor_id</code> int(11) NOT NULL,<br>    <code>remark</code> varchar(255) DEFAULT NULL,<br>    PRIMARY KEY (<code>id</code>),<br>    KEY <code>idx_film_actor_id</code> (<code>film_id</code>,<code>actor_id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>INSERT INTO <code>film_actor</code> (<code>id</code>, <code>film_id</code>, <code>actor_id</code>) VALUES (1,1,1),(2,1,2),(3,2,1);</p>
<p>explain 两个变种<br> （1）explain extended：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<p>mysql&gt; explain extended select * from film where id = 1;<br>mysql&gt; show warnings;</p>
<p> （2）explain partitions：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<p>explain 中的列<br>1<br>explain select * from actor;<br>以上的执行计划结果：</p>
<ol>
<li>id 列<br>id 列的编号是 select 的序列号，有几个 select 就有几个id，并且 id 的出现顺序是按 select 出现的顺序增长的。</li>
</ol>
<p>id 列越大执行优先级越高，id 相同则从上往下执行，id为NULL最后执行。</p>
<ol start="2">
<li>select_type 列<br>select_type 表示对应行是简单还是复杂的查询。简单查询只有 simple，复杂查询有：primary，subquery，derived，union；</li>
</ol>
<p>（1）simple：简单查询。查询不包含 子查询 和 union；</p>
<p>mysql&gt; explain select * from film where id = 2;</p>
<p>（2）primary：最外层的 select ；—-复杂查询<br>（3）subquery：包含在 select 中的子查询（不在 from 子句中） – 复杂查询<br>（4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） ； –复杂查询<br>用下面的例子了解 primary、subquery 和 derived 类型： </p>
<p>mysql&gt; set session optimizer_switch=’derived_merge=off’; #关闭mysql5.7新特性对衍生表的合并优化<br>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;<br>mysql&gt; set session optimizer_switch=’derived_merge=on’; #还原默认配置</p>
<p>分析SQL的执行顺序： 先执行 film 表的查询 –&gt; 再执行 actor 表的查询 –&gt; 最后再执行生成的临时表查询；</p>
<p>第1行（ id 为 1）的 select_type 为 primary，表示的最外层的查询；id 为 1，是最小的，则最后执行；</p>
<p>第2行（ id 为 3）的 select_type 为 derived，表示的 from 后面的子查询，也叫派生表，别名为 der 的派生表；id 为 3，是最大的，则最先执行的；</p>
<p>第3行（id 为 2）的 select_type 为 subquery，表示的 from 前面的子查询；id 为 2，是中间的，则在中间执行；</p>
<p>（5）union：在 union 中的第二个和之后的 select 都为 union；</p>
<p>mysql&gt; explain select 1 union all select 1;</p>
<ol start="3">
<li>table 列<br>这一列表示 explain 的一行正在访问哪个表。</li>
</ol>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。</p>
<p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的select 行 id。</p>
<p>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p>
<p>mysql&gt; explain select min(id) from film;</p>
<ol start="4">
<li>type列<br>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。</li>
</ol>
<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p>
<p>一般来说，得保证查询达到 range 级别，最好达到 ref；</p>
<p>  （1）const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。 system = 1。</p>
<p>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条数据匹配时为 system；   （使用主键或者唯一索引的时候会出现）</p>
<p>mysql&gt; set session optimizer_switch=’derived_merge=off’; #关闭mysql5.7新特性对衍生表的合并优化<br>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;<br>mysql&gt; set session optimizer_switch=’derived_merge=on’; #还原默认配置</p>
<p>（2）eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p>
<p>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<p>（在连接查询的时候，使用了主键或唯一索引的全部字段）</p>
<p>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</p>
<p> 说明：   film_id：表的联合索引中的一个字段 ，但是 type 为 All; </p>
<p> 因为使用的 * 查询的，指的要查询所有的字段，但是 film_actor 表的 remark 字段没有建立索引的，所以需要全表扫描；</p>
<p> （3）ref：相比 eq_ref，不使用唯一索引，而是使用普通索引 或者 唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行；</p>
<p>（使用的普通索引 或 联合唯一索引的部分前缀）</p>
<pre><code>&lt;1&gt; 简单 select 查询，name是普通索引（非唯一索引）
</code></pre>
<p>mysql&gt; explain select * from film where name = ‘film1’; </p>
<pre><code>&lt;2&gt; 关联表查询，idx_film_actor_id 是 film_id 和 actor_id 的联合索引，这里使用到了film_actor的左边前缀 film_id 部分。
</code></pre>
<p>mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</p>
<p> （4）range：范围扫描通常出现在  in(),  between ,  &gt; ,   &lt;,  &gt;= 等操作中。使用一个索引来检索给定范围的行。 </p>
<p>mysql&gt; explain select * from actor where id &gt; 1;</p>
<p> （5）index：扫描全表索引，通常比 All 快一些；</p>
<p>1<br>mysql&gt; explain select * from film;<br>film 表的所有字段都建立了索引，使用 * 查询，则 type 为 index；</p>
<p>（6）ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了。</p>
<p>mysql&gt; explain select * from actor;</p>
<ol start="5">
<li><p>possible_keys 列<br>这一列显示查询 可能 使用哪些 索引 来查找。<br>explain 时可能出现 possible_keys 有值，而 key 显示 NULL 的情况，这是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
</li>
<li><p>key 列<br>这一列显示mysql 实际 采用哪个 索引 来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视 possible_keys 列中的索引，在查询中使用 force index、ignore index。</p>
</li>
</ol>
<p>1<br>mysql&gt; explain select * from film where name = ‘film1’;</p>
<ol start="7">
<li>key_len列<br>这一列显示了mysql 在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</li>
</ol>
<p>mysql&gt; explain select * from film_actor where film_id = 2;</p>
<p>key_len计算规则如下：</p>
<p>复制代码<br>复制代码<br>复制代码<br>字符串<br>    char(n)：n字节长度<br>    varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2<br>数值类型<br>    tinyint：1字节<br>    smallint：2字节<br>    int：4字节<br>    bigint：8字节<br>时间类型<br>    date：3字节<br>    timestamp：4字节<br>    datetime：8字节<br>复制代码<br>复制代码<br>复制代码<br>注意：如果字段允许为 NULL，需要1字节记录是否为 NULL</p>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<ol start="8">
<li><p>ref列<br>这一列显示了在 key 列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）。</p>
</li>
<li><p>rows列<br>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。扫描的索引可能的行数</p>
</li>
<li><p>Extra列<br>这一列展示的是额外信息。常见的重要值如下：</p>
</li>
</ol>
<p>Using index &gt;  Using index condition &gt; Using where </p>
<p>（1）Using index：使用覆盖索引；覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。也就是查询的结果集中的所有字段都是在索引中的；</p>
<p>mysql&gt; explain select film_id from film_actor where film_id = 1;</p>
<p>（2）Using index condition：查询的列不完全被索引覆盖，where条件中是一个联合索引的前导列的范围；</p>
<p>mysql&gt; explain select * from film_actor where film_id &gt; 1;</p>
<p>（3）Using where：使用 where 语句来处理结果，查询的列未被索引覆盖；在查找使用索引的情况下，需要回表去查询所需的数据</p>
<p>mysql&gt; explain select * from actor where name = ‘a’;</p>
<p>（4）Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<p>   &lt;1&gt;  actor.name没有索引，此时创建了张临时表来 distinct；（distinct 查询可能会使用到临时表）</p>
<p>mysql&gt; explain select distinct name from actor;</p>
<p>   &lt;2&gt; film.name 建立了 idx_name 索引，此时查询时 extra 是 using index, 没有用临时表；将索引树加载到内存中，然后去重；</p>
<p>mysql&gt; explain select distinct name from film;</p>
<p> （5）Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p>
<p>  &lt;1&gt; actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</p>
<p>mysql&gt; explain select * from actor order by name;</p>
<p>  &lt;2&gt; film.name建立了idx_name索引,此时查询时extra是using index</p>
<p>mysql&gt; explain select * from film order by name;</p>
<p> （6）Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段；已经被 MySQL 优化过了；</p>
<p>mysql&gt; explain select min(id) from film;</p>
<p>索引实践<br> 示例表的创建</p>
<p>复制代码<br>复制代码<br>复制代码<br>CREATE TABLE <code>employees</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>    <code>name</code> varchar(24) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’,<br>    <code>age</code> int(11) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>    <code>position</code> varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘职位’,<br>    <code>hire_time</code> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘入职时间’,<br>    PRIMARY KEY (<code>id</code>),<br>    KEY <code>idx_name_age_position</code> (<code>name</code>,<code>age</code>,<code>position</code>) USING BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=’员工记录表’;</p>
<p>INSERT INTO employees(name,age,position,hire_time) VALUES(‘LiLei’,22,’manager’,NOW());<br>INSERT INTO employees(name,age,position,hire_time) VALUES(‘HanMeimei’,23,’dev’,NOW());<br>INSERT INTO employees(name,age,position,hire_time) VALUES(‘Lucy’,23,’dev’,NOW());<br>复制代码<br>复制代码<br>复制代码<br>1、全值匹配<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’;</p>
<p>name 是 联合索引 idx_name_age_position 的前导字段； </p>
<p> key_len 为 74，name为 varchar(24)，则 3 * 24 + 2 = 74，所以使用联合索引中的 name 字段走的索引；</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22;</p>
<p> name，age 是联合索引 idx_name_age_position 的字段； </p>
<p> key_len 为 78，name为 varchar(24)，则 3 * 24 + 2 = 74；age 为 int ，所以值为4 ； 74 + 4 = 78，所以使用联合索引中的 name，age 字段走的索引；</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>  name，age，position 是联合索引 idx_name_age_position 的字段； </p>
<p> key_len 为 140，name为 varchar(24) 类型，则 3 * 24 + 2 = 74；age 为 int 类型，所以值为4；position 为 varchaer(20)，所以值为 3 * 20 + 2 = 62； 74 + 4 + 62 = 140，所以使用联合索引中的 name，age，position 字段走的索引；</p>
<p> 2.最左前缀法则<br> 如果建立了联合索引，要遵守最左前缀法则。指的是查询从联合索引的最左前列开始并且不跳过索引中的列。 </p>
<p>（1）使用了联合索引的前两个字段查询；</p>
<p>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ and age = 22; #name，age 都走了索引</p>
<p> key_len 为 78，（3 * 24 + 2） + 4 = 78；走了 name 和 age 索引；</p>
<p> （2）使用联合索引的第1, 3 字段查询</p>
<p>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ and position =’manager’; #只有 name 走了索引</p>
<p> key_len 为 74，name 的 长刚好为 74，所以只有 name 走了索引；</p>
<p>分析：联合索引的底层存储是 先比较最前面的字段，最前面的字段一样则比较第2个字段，第2个一样才去比较第3个字段；第1个字段 name 去比较了，可以搜索到一部分， position 为 联合索引的第3个字段，但是索引在存储和查找时候不可能跳过第2个字段直接去比较第3个字段的，position 字段还是要列出大范围的数据做查询，因此 name 走了索引，position 没有走索引。</p>
<ol start="3">
<li>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描<br>（1）不给索引列进行函数操作</li>
</ol>
<p>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p>一般来说，只要给索引列增加了函数操作，MySQL的底层直接就不会使用索引去处理的。</p>
<p>（2）给 hire_time 增加一个普通索引：</p>
<p>ALTER TABLE <code>employees</code><br>ADD INDEX <code>idx_hire_time</code> (<code>hire_time</code>) USING BTREE ;<br>EXPLAIN select * from employees where date(hire_time) =’2018-09-30’; #不会走索引</p>
<p> 针对以上的SQL，转化为日期范围查询，就会走索引：</p>
<p>EXPLAIN select * from employees where hire_time &gt;=’2018-09-30 00:00:00’ and hire_time &lt;=’2018-09-30 23:59:59’;</p>
<p> 还原最初索引状态</p>
<p>ALTER TABLE <code>employees</code><br>DROP INDEX <code>idx_hire_time</code>;<br>4.存储引擎不能使用索引中范围查找条件右边的列<br>联合索引的字段顺序，范围查找之后的列都不会去走索引；</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’; #3个字段索引都会走<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p> 只会走前两个字段的索引。 第一个字段 name 使用的相等，所以可以找到具体的数据，第2个字段会缩小到一个范围，第3个字段是在这个范围里做相等的查询，还是会要将这个范围去遍历一遍的，所以只有 name，age 走了索引。</p>
<p>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句<br>EXPLAIN SELECT name,age FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<ol start="6">
<li>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’;</li>
</ol>
<ol start="7">
<li>is null, is not null 也无法使用索引<br>建议在建立字段的时候都设置为 not null，设置一个默认的值；</li>
</ol>
<p>EXPLAIN SELECT * FROM employees WHERE name is null</p>
<ol start="8">
<li>like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作<br>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’</li>
</ol>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’</p>
<p>模糊查找的时候，前模糊不走索引，后模糊会走索引；</p>
<p>因为在后模糊的时候，我们知道了这个字段的前面有几个字符，我们在索引中比较的只去比较前面的几个字符就好了；</p>
<p>问题：解决like ‘%字符串%’索引不被使用的方法？  </p>
<p>（a）使用覆盖索引，查询字段必须是建立覆盖索引字段  </p>
<p>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;</p>
<p> （b）如果不能使用覆盖索引则可能需要借助搜索引擎</p>
<ol start="9">
<li>字符串不加单引号索引失效<br>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’; #会走索引<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;   #不会走索引</li>
</ol>
<p> 因为 name 为字符串类型，MySql 会做隐式的类型转换，做了类型的转换，所以不会去走索引；</p>
<p>10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’;</p>
<p> 11.范围查询优化<br>给年龄添加单值索引 ： ALTER TABLE <code>employees</code> ADD INDEX <code>idx_age</code> (<code>age</code>) USING BTREE ;</p>
<p>explain select * from employees where age &gt;=1 and age &lt;=2000; </p>
<p>从执行计划的结果可以看出，以上的范围查找不会走索引；</p>
<p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引</p>
<p>优化方法：可以将大的范围拆分成多个小范围</p>
<p>explain select * from employees where age &gt;=1 and age &lt;=1000;<br>explain select * from employees where age &gt;=1001 and age &lt;=2000;</p>
<p> 还原最初索引状态：ALTER TABLE <code>employees</code> DROP INDEX <code>idx_age</code>;</p>
<p>索引使用总结（一般情况下）<br>建立了一个联合索引： (a， b，c)</p>
<p> like KK%相当于常量，所以走索引；%KK和%KK% 相当于范围，所以不走索引；</p>
<p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引优化方法：可以讲大的范围拆分成多个小范围。</p>
<p>使用覆盖索引的时候就会出现</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-基础语法</title>
    <url>/2023/10/21/Java%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>一、关键字<br>关键字<br>定义：被Java 语言赋予了特殊含义，用做专门用途的字符串（单词）。<br>特点： 关键字中所有字母都为小写。<br>例子：class、interface、 enum 、byte 、short、 int 、long、 float、 double、 char、boolean、 void<span id="more"></span></p>
<p>二、保留字<br>Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用，自己命名标识符时要避免使用这些保留字。<br>例子：goto 、const</p>
<p>三、标识符<br>标识符 ：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p>
<p>定义合法标识符规则：<br>标识符就是名称的意思，所有的名字都统称为标识符<br>Java 中经常要定义类、方法、变量等，在定义的时候需要给它们取名字，这些名字就是标识符。只有字母（区分大小写），下划线 (_)，美元符号 ($) 和数字组成，长度不受限制，第一个字母不能是数字，不能用数字开头，不能是关键字，不能是 true、false、null (尽管三个都不是关键字，而是 常量标识)。</p>
<p>Java中的名称命名规范（驼峰命名法）：<br>包名：多单词组成时所有字母都小写：xxxyyyzzz<br>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz<br>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个<br>单词首字母大写：xxxYyyZzz<br>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
<p>四、变量<br>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。<br>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。</p>
<p>字节：字节是我们常见的计算机中最小存储单元，计算机存储任何的数据，都是以字节的形式存储。<br>8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8 bit = 1 B</span><br><span class="line">1024 B =1 KB</span><br><span class="line">1024 KB =1 MB</span><br><span class="line">1024 MB =1 GB</span><br><span class="line">1024 GB = 1 TB</span><br></pre></td></tr></table></figure>

<p>Java语言中数据类型：2大类</p>
<p>基本数据类型：4类8种</p>
<p>布尔类型：boolean，数值只有2个：true，false，默认false<br>字符类型：char，2个字节(16bit)</p>
<p>整数类型：<br>byte，字节。1字节(8bit)，-128（-2^7）到127（2^7-1）默认值0<br>short，短整型。2字节(16bit)，-32768（-2^15）到32767（2^15-1）默认值0<br>int，整型。(默认类型)。4字节(32bit)，-2^31 到2^31-1 默认值0<br>long，长整型。加L或l。8个字节(64bit)，-2^63 到2^63-1 默认值0L<br>注意：<br>Java的整数类型数据默认为int类型，声明为long类型时须在变量值的末尾加上一个’l’或’L’，不加不会报错，不加 ‘L’ 默认是 int 型，int 转为 long 是安全的（小转大为自动类型转换，不会损失精度），所以会自动转，能编译通过，但是当变量值超过了 int 的表数范围时，必须添加 ‘l’ 或 ‘L’ ，否则编译不通过，会报错</p>
<p>浮点类型：<br>float，单精度。加f或F。4个字节(32bit)，默认值0.0f<br>double，双精度。(默认类型)。8个字节(64bit)，默认值0.0d<br>注意：<br>//3.浮点数不加 ‘F’ 默认是 double 类型，double 转 float 可能损失精度，因为不会自动转，编译是通不过的<br>声明 float 型变量变量值后不加 ‘f’ 或 ‘F’ 编译不能通过，原因是浮点型变量值默认是 double 类型，占用 8 字节，声明为 float 类型为 4 个字节，大转小为强制类型转换，不会自动转，会损失精度，编译是通不过的会报错。</p>
<p>引用数据类型：String、接口（interface）、数组（[]）</p>
<p>定义变量：<br>数据类型 变量名 = 数据值;<br>变量：计算机内存中的一块存储空间，是存储数据的基本单元。</p>
<p>基本数据类型的转换<br>Java允许程序员在一定程度上进行数据类型的转换。<br>8种基本数据类型：<br>7种数值类型可以参加转换：byte，short，char，int，long，float，double（boolean不参加）。<br>显式转换<br>显式转换(强制转换)：取值范围大的转为取值范围小的。<br>小范围数据类型 变量 = (小范围数据类型 变量)大范围数据类型;<br>int n = (int)6.7;<br>语法结构：(要转换的类型)数值<br>隐式转换<br>隐式转换(自动转换)：取值范围小的转为取值范围大的。<br>大范围数据类型 变量 = 小范围的数据类型;<br>double d = 10000;</p>
<p>五、程序流程控制</p>
<p>java中break和continue的区别：</p>
<p>break在循环体内，强行结束当前循环的执行，也就是结束整个循环过程，不在判断执行循环的条件是否成立，直接转向循环语句下面的语句，只能跳出一层循环，如果你的循环是嵌套循环，那么你需要按照你嵌套的层次，逐步使用break来跳出。[逐层判断，逐步跳出]，当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int num = 5;</span><br><span class="line">        switch (num)&#123;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(<span class="string">&quot;非法数字&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> 1:</span><br><span class="line">                System.out.println(<span class="string">&quot;第一季度&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> 2:</span><br><span class="line">                System.out.println(<span class="string">&quot;第二季度&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> 3:</span><br><span class="line">                System.out.println(<span class="string">&quot;第三季度&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> 4:</span><br><span class="line">                System.out.println(<span class="string">&quot;第四季度&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>没有符合5的，结果是输出default结果和case1的结果，因为default中没有break结束。<br>跳出多层循环<br>java中跳出多层循环，可以在外层循环前定义一个标号，然后在内层循环体中使用带标号的break语句，即可跳出外层循环。<br>在循环开头和break后面加标号，直接跳出最外层的循环。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == 5) &#123;</span><br><span class="line">                <span class="built_in">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>continue终止本次满足条件循环的执行，即跳过当前这次循环中continue语句后尚未执行的语句，接着进行下一次循环条件的判断。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-数组与异常处理</title>
    <url>/2023/10/25/Java%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>数组拷贝<br>浅拷贝：拷贝的是内存地址，<br>int[] nums = new int[3];<br>int[] arr = nums;//拷贝的是内存地址，原数组值会变。<span id="more"></span></p>
<p>深拷贝：拷贝的是数值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int[] arr2 = new int[3];</span><br><span class="line"><span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">    arr2[i] = nums[i];//拷贝的是数值，对原数组值不影响。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用方法:<br>binarySearch(数组，key)–&gt;int，二分搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int[] arr1 = &#123;1,3,4,5,8,3&#125;;</span><br><span class="line">int key = 5;</span><br><span class="line">System.out.println(<span class="string">&quot;5所在的下标：&quot;</span>+Arrays.binarySearch(arr1,key));</span><br></pre></td></tr></table></figure>

<p>//Arrays.copyOf,从arr1数组中找打4个元素给新的数组<br>int[] arr2 = Arrays.copyOf(arr1,15);//深拷贝,15表示新数组长度</p>
<p>//两个数组是否值一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int[] arr3 = &#123;1,3,4,5&#125;;</span><br><span class="line">int[] arr4 = &#123;1,3,4,5&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;两个数组是否相等：&quot;</span>+arr3.equals(arr4));//<span class="literal">false</span></span><br><span class="line">System.out.println(<span class="string">&quot;两个数组是否相等：&quot;</span>+Arrays.equals(arr3,arr4));//<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>打印数组<br>System.out.println(Arrays.toString(arr4));//[1, 3, 4, 5]</p>
<p>数组默认值<br>boolean[] arr5 = new boolean[5];<br>Arrays.fill(arr5,false);//[false, false, false, false, false]</p>
<p>数组排序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int[] arr6 = &#123;4,43,6,4,7&#125;;</span><br><span class="line">Arrays.sort(arr6);</span><br><span class="line">System.out.println(Arrays.toString(arr6));//[4, 4, 6, 7, 43]</span><br></pre></td></tr></table></figure>

<p>异常</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-面向对象（一）</title>
    <url>/2023/10/21/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>修饰符：public，static<br>返回值：一个方法执行之后，返回给调用处的结果。可能有，也可能没有。<span id="more"></span><br>有：在方法定义的时候，写清楚方法要返回的数据的类型。<br>没有：void，表示这个方法执行结束之后，没有返回值给调用处。<br>方法名：也是一种标识符。首字母小写，驼峰式命名。<br>()：方法的标志。括号里：参数列表<br>{}：方法体<br>参数列表：方法在运算过程中的未知数据，调用者调用方法时传递<br>return ：将方法执行后的结果带给调用者，方法执行到 return ，整体方法运行结束</p>
<p>static的方法：静态方法<br>类名.方法名()，本类中类名可以省略。<br>非static的方法：非静态方法<br>创建该类的对象，通过对象调用方法。<br>类名 对象名 = new 类名();<br>对象.方法名()<br>调用一个方法,如果是类的方法，可以用类名直接调用<br>//倘若是在本类中，那么类名可以省略</p>
<p>注意点：<br>1.如果一个方法声明了有返回值(非void)，那么方法中一定要使用return语句返回结果。<br>2.定义方法的时候，声明的返回值类型，一定得和return后实际上返回的数值类型一致。<br>3.如果一个方法声明了有返回值，如果方法中有分支语句或者循环语句，那么要保证无论执行哪个分<br>支，都要有return可以被执行到。<br>4.如果一个方法声明没有返回值(void)，那么方法中也可以使用return语句，用于强制结束方法的执<br>行。</p>
<p>方法的重载和重写：<br>方法的重载和重写都是实现多态的方式。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同、顺序不同），不同返回类型（也可以相同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，返回值和形参都不能改变。即外壳不变，核心重写！重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p>
<p>this关键字<br>this代表所在类的当前对象的引用（地址值），即对象自己的引用。<br>方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-面向对象（三）</title>
    <url>/2023/10/21/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>多态 (多种形态) 是同一个行为具有多个不同表现形式或形态的能力，多态就是同一个接口，使用不同<br>的实例而执行不同操作。<span id="more"></span></p>
<p>父类类型 变量名 = new 子类对象；<br>变量名.方法名();<br>父类类型：指子类对象继承的父类类型，或者实现的父接口类型</p>
<p>引用类型转换<br>父子对象之间的转换分为了向上转型和向下转型 , 它们区别如下:<br>向上转型： 通过子类对象 (小范围) 实例化父类对象 (大范围)，这种属于自动转换<br>// 通过子类去实例化父类,调用父类的方法<br>父类类型 变量名 = new 子类对象<br>方法重写了，变量名.重写方法执行的是子类重写的新的方法。</p>
<p>向下转型： 通过父类对象 (大范围) 实例化子类对象 (小范围)，这种属于强制转换<br>向下转型则是为了，通过父类强制转换为子类，从而来调用子类独有的方法，为了保证向下转型的顺利完成，在 Java 中提供了一个关键字 instanceof, 通过 instanceof 可以判断某对象是否是某类的实例，如果是则返回 true, 否则为 false<br>instanceof：判断某个对象是否是某个类的实例：类以及继承的父类</p>
<p>看一个对象能够访问哪些成员，看=左边是定义的是什么类型<br>父类类型：只能访问父类的属性和方法，<br>子类类型：可以访问父类的属性和方法，子类新增，子类重写<br>看一个对象最终访问哪个方法，看=右边是什么类型的对象<br>父类对象：父类属性和方法<br>子类对象：父类的属性和方法，以及子类重写的方法</p>
<p>所有的类，都是以继承结构存在的。如果没有显示的父类，默认继承Object类。<br>任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承。<br>Object类中所定义的方法，是所有对象都具备的方法。<br>Object类型可以存储任何对象。<br>作为参数，可接受任何对象。<br>作为返回值，可返回任何对象。</p>
<p>equals()方法：<br>默认实现为(this == obj)，比较两个对象地址是否相同。可进行覆盖，比较两个对象的内容是否相同。</p>
<p>equals重写步骤：<br>比较两个引用是否指向同一个对象。<br>判断obj是否为null。<br>判断两个引用指向的实际对象类型是否一致。<br>强制类型转换。<br>依次比较各个属性值是否相同。<br>重写equals的意义：有时候我们不想判断内存是否相等，我们就想知道属性是否相同。</p>
<p>finalize()方法<br>当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列。<br>垃圾对象：没有有效引用指向此对象时，为垃圾对象。<br>垃圾回收： 由GC销毁垃圾对象，释放数据存储空间。<br>自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象。<br>手动回收机制：使用System.gc(); 通知JVM执行垃圾回收。</p>
<p>抽象类：<br>将子类的共同特征进行抽取，抽象成一个父类。如果有的功能在父类中定义了，但是没有具体的实现，那么可以定义为抽象的。等待子类实现即可。</p>
<p>抽象类 ：包含抽象方法的类；<br>被abstract修饰的类，称为抽象类；<br>public abstract class 类名 {}<br>抽象类意为不够完整的类、不够具体的类；</p>
<p>抽象方法 ： 没有方法体的方法。<br>public abstract 返回值类型 方法名(参数);</p>
<p>抽象类不允许被实例化，因为可能包含有抽象方法，必须等待子类来继承，并且实现抽象方法。子类积极的实现父类中的抽象方法，但是如果没有全部实现，那么子类也是抽象的，要再等子类来继承，并且实现抽象方法。<br>1、抽象类不能被实例化，即不能使用new关键字来实例化对象，只能被继承；<br>2、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；<br>3、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；<br>4、抽象类中的抽象方法只有方法体，没有具体实现；<br>5、如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。实现了可以不为抽象类。<br>6、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p>
<p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。<br>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并<br>不是类，而是另外一种引用数据类型。<br>引用数据类型：数组，类，接口。</p>
<p>接口定义<br>含有抽象方法<br>抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。<br>默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。实现类可以不重写默认方法，避免了接口加方法后多个实现类需要重写。<br>静态方法：使用 static 修饰，供接口直接调用。<br>私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。</p>
<p>接口最重要的体现:解决单继承的弊端。将多继承这种机制在Java中通过多实现完成了。<br>怎么解决多继承的弊端?<br>弊端:多继承时，当多个父类中有相同的功能时，子类调用会产生不确定性。其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。</p>
<p>为什么多实现能解决呢?<br>因为接口中的功能都没有方法体，由子类来明确一个类继承类同时可以实现接口接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了，子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-深入理解Mysql索引底层数据结构与算法</title>
    <url>/2022/04/24/Mysql-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>什么是索引？<br>索引（index）是帮助MySQL高效获取数据的一种有序数据结构，索引存储在对应的本地文件里。</p>
<span id="more"></span>

<p>二叉树<br>左边子节点的数据小于父节点数据，右边子节点的数据大于父节点数据。如果col2是索引，查找索引为89的行元素，那么只需要查找两次，就可以获取到行元素所在的磁盘指针地址。<br>二叉树.png<br>如果col1是索引，查找索引为6的行元素，那么需要查找六次，就可以获取到行元素所在的磁盘指针地址，即得到了该索引为6的行元素。因此二叉树不适合存储单边增长的序列字段，近乎全表扫描获取数据。</p>
<p>索引为什么不使用二叉树作为索引结构？<br>二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢</p>
<p>红黑树<br>本质二叉树，属于二叉平衡树，jdk1.8 hashmap的底层实现；存储大数据量，树的高度不可控， 数量越大，树的高度越高；500w行数据，2的n次方=500w数据量， n是树的高度，也就是查询次数；</p>
<p>hash索引<br>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p>Hash索引特点<br>1.Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，…）<br>2.无法利用索引完成排序操作<br>3.查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</p>
<p>B树<br>又称多路平衡查找树，叶节点具有相同的深度，叶节点的指针为空，所有索引元素不重复，节点中的数据索引从左到右递增排列。<br>B数.png</p>
<p>B+树（B树的变种）<br>非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低。叶子节点包含所有索引字段，叶子节点比b树增加了指针连接，叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；<br>B+树.png</p>
<p>为什么 MySQL 的索引要使用 B+ 树而不是其他树形结构?比如 B 树?<br>因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</p>
<p>B+树和B树有什么不同？</p>
<p>为什么mysql页文件默认16K？</p>
<p>MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)那么一颗高度为2的B+树能存储的数据为：117016=18720条，一颗高度为3的B+树能存储的数据为：11701170*16=21902400（千万级条）。因此，B+树存储大数据量的表也可以非常高效的获取数据，MySQL使用B+树作为索引的数据结构。<br>可以通过下面命令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show global status like `Innodb_page_size`</span><br></pre></td></tr></table></figure>
<p>存储引擎<br>存储引擎最终作用于表，不是数据库在mysql的安装的根目录下，有一个data目录，里面存放的是所有表的数据。</p>
<p>MyISAM：<br>MyISAM索引文件和数据文件是分离的（非聚集或稀疏）。frm文件：存储这张表的表结构。MYD文件：存储这张表的所有数据行。MYI文件：存储这张表的索引字段。</p>
<p>InnoDB（聚集）：<br>表数据文件本身是按照B+tree组织的一个索引结构文件。frm文件：存储这张表的表结构，ibd文件：存储这张表的所有数据行和索引字段聚集(聚簇)索引—-叶节点包含完整数据记录。</p>
<p>聚集索引选取规则：<br>如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引。如果表没有主键，或没有合适的唯一索引，则nnoDB会自动生成一个rowid作为隐藏的聚集索引。</p>
<p>为什么InnoDB存储引擎选择使用B+tree索引结构？</p>
<ul>
<li>相对于二叉树，层级更少，搜索效率高；</li>
<li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li>
<li>相对Hash索引，B+tree支持范围匹配及排序操作；</li>
</ul>
<p>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</p>
<ul>
<li>首先，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率，因此InnoDB必须要有主键。如果不手动指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。</li>
<li>其次，索引的数据类型是整型，一方面整型占有的磁盘空间或内存空间相比字符串更少，另一方面整型比较比字符串比较更快速，字符串比较是先转换为ASCII码，然后再比较的。</li>
<li>最后，B+树本质是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。</li>
</ul>
<p>为什么非主键索引结构叶子节点存储的是主键值？<br>主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；<br>如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。</p>
<p>Mysql数据库中，什么情况下设置了索引但无法使用?<br>1.没有符合最左前缀原则<br>2.字段进行了隐私数据类型转化<br>3.走索引没有全表扫描效率高</p>
<p>Innodb是如何实现事务的<br>Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以一个update语句为例:<br>1.Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中<br>2.执行update语句，修改Buffer Pool中的数据，也就是内存中的数据<br>3.针对update语句生成一个RedoLog对象，并存入LogBuffer中<br>4.针对update语句生成undolog日志，用于事务回滚<br>5.如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中6.如果事务回滚，则利用undolog日志进行回滚</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-面向对象（二）</title>
    <url>/2023/10/21/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>static关键字<br>静态（static）可以修饰属性和方法，修饰类的话只能说内部类。<br>称为静态属性（类属性）、静态方法（类方法）。<span id="more"></span><br>静态成员是全类所有对象共享的成员。<br>在全类中只有一份，不因创建多个对象而产生多份。<br>不必创建对象，可直接通过类名访问。<br>this，super关键字，不能出现在static方法中。</p>
<p>静态属性<br>形成静态属性，不再属于对象。非静态属性（实例属性）属于对象，随着对象的创建而产生，每个对象的属性值都是独立的。<br>静态属性是属于类的，只有一份(节省内存)。应该由类来访问，但是对象也可以访问，所有的对象共享着一份数据。<br>非静态属性由对象访问：对象.属性–&gt;赋值，取值<br>静态属性由类访问：类名.静态属性–&gt;赋值，取值</p>
<p>实例对象支持调用静态变量和静态方法，但并不推荐这么用;<br>通过实例对象支持调用静态变量和静态方法，最终都会在编译后转换为类直接调用静态变量或静态方法。</p>
<p>静态方法<br>形成了静态方法。属于类而不再属于对象了，应该由类来访问，但是对象也可以访问。<br>普通的方法由对象调用。<br>静态方法中：只能访问属于类，不能访问属于对象。<br>A：访问静态属性<br>B：访问静态方法<br>C：不能直接访问非静态属性<br>D：不能直接访问非静态方法<br>非静态方法中：属于类，属于对象都可以访问<br>A：访问静态属性<br>B：访问静态方法<br>C：访问非静态属性<br>D：访问非静态方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public void <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line"> System.out.println(this.name+<span class="string">&quot;,吃东西啦。。。&quot;</span>); //非静态方法，可以访问非静态属性</span><br><span class="line"> System.out.println(<span class="string">&quot;城市：&quot;</span>+Person.city); //非静态方法，可以访问静态属性</span><br><span class="line"> this.showInfo(); // 非静态方法，可以调用非静态方法。</span><br><span class="line"> Person.printCity(); //非静态方法，可以调用静态方法。</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void <span class="function"><span class="title">test1</span></span>()&#123; //属于类的</span><br><span class="line"> System.out.println(Person.city); //静态方法中，可以访问静态属性。</span><br><span class="line"> Person.printCity();//静态方法中，可以访问静态方法。</span><br><span class="line"> // System.out.println(name); //静态方法中，不能访问非静态的属性</span><br><span class="line"> // this.showInfo(); //静态方法中，不能调用非静态的方法。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通代码块：{}包裹起来一段代码。注意作用域。<br>构造代码块：写在类里，方法外的代码块，就叫构造代码块。当创建对象的时候，随着构造函数的调用而执行。而且优先于构造函数执行。构造函数被多次调用，那么构造代码块也被多次调用。</p>
<p>静态代码块：用static关键字修饰的代码块。在类第一次使用的时候执行，优先于main的执行。只执行一次。例如连接数据库的驱动等<br>同步代码块：多线程。</p>
<p>优先级别：静态代码块 &gt; 构造代码块 &gt;构造方法</p>
<p>继承<br>描述两个类的关系的。在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类(派生类，<br>SubClass)，现有类被称作父类(超类，SuperClass)，子类会自动拥有父类所有非私有的属性和方法。</p>
<p>意义<br>避免重复的代码。(从子类的角度)<br>扩展类的功能。(从父类的角度)<br>子类对象，可以直接访问父类的非私有的属性和方法。(避免重复代码)<br>子类也可以新增自己的属性和方法。(扩展类的功能)<br>子类可以重新实现父类已有的方法。(扩展类的功能，如重写)</p>
<p>super关键字<br>子类对象的创建过程：<br>子类的构造方法中，默认先调用父类的无参构造方法。如果没有显示的调用，那么隐含着super()。</p>
<p>可以访问父类的属性<br>可以访问父类的方法<br>指代父类的构造方法， s如果有多个，靠参数来区分。要在第一行。</p>
<p>this关键字：<br>作为本类的对象，<br>访问本类的属性。如果在继承中，本类没有这个属性，那么再找父类中。<br>访问本类的方法<br>可以指代本类的构造方法：this()。要在第一行。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习一</title>
    <url>/2023/02/01/Redis%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<h3 id="Windows中想查看某个端口被那个程序占用。-4000端口作例子"><a href="#Windows中想查看某个端口被那个程序占用。-4000端口作例子" class="headerlink" title="Windows中想查看某个端口被那个程序占用。(4000端口作例子)"></a>Windows中想查看某个端口被那个程序占用。(4000端口作例子)</h3><span id="more"></span>

<p>第一步：查看端口是否被占用</p>
<p>在windows控制台输入指令：netstat -ano</p>
<p>第二步，查看此时4000端口被那个进程占用。</p>
<p>这里看到是pid对应1152</p>
<p>在windows控制台输入指令：tasklist | findstr “1152”</p>
<p>在windows下查看端口被占用情况</p>
<p>此处可以看出，本地node.exe进程，在使用1152端口和外部程序进行通讯。</p>
<p>简化过程</p>
<p>直接在windos控制台输入指令：netstat -ano | findstr “4000”。</p>
<p>再输入指令：tasklist | findstr “1152”</p>
<p>这里可以通过pid停止进程:taskkill /F /pid 1152</p>
<p>Git Bash中按下Ctrl+C无法中断hexo s的解决方法<br>1、打开cmd；<br>2、复制 taskkill /F /IM node.exe，粘贴运行；<br>3、搞定！</p>
<h3 id="知道一个程序进程，查找这个进程占用的端口。"><a href="#知道一个程序进程，查找这个进程占用的端口。" class="headerlink" title="知道一个程序进程，查找这个进程占用的端口。"></a>知道一个程序进程，查找这个进程占用的端口。</h3><p>以arcgis用户使用的 javaw.exe进程为例</p>
<p>第一步：确认进程的PID</p>
<p>在任务管理器中设置显示目标进程的PID</p>
<p>此处可以看到javaw.exe的PID编号为：“4892”和“1152”</p>
<p>第二步：查找进程占用的端口号</p>
<p>直接在windos控制台输入指令：netstat -ano | findstr 1152。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习二</title>
    <url>/2023/02/01/Redis%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><p>是一个使用C语言编写的，开源的高性能非关系型（NoSQL）的键值对数据库。</p>
<span id="more"></span>

<p>特点：<br>开源免费，C语言编写，单线程，k/v结构高性能，基于内存运行，可持久化。<br>作用：<br>主要来做缓存，它的计数器可以做分布式唯一主键，还能实现分布式锁，队列，会话缓存，点赞，统计网站访问量</p>
<h2 id="为什么要缓存，为什么用Redis来做缓存？"><a href="#为什么要缓存，为什么用Redis来做缓存？" class="headerlink" title="为什么要缓存，为什么用Redis来做缓存？"></a>为什么要缓存，为什么用Redis来做缓存？</h2><p>当第一次访问数据库中的数据，因为是从硬盘上读取的,硬盘的寻址速度是毫秒级的。用缓存的话从数据库中获取到数据后将数据存在Redis中，这样下一次再访问这些数据的时候就可以直接从Redis中获取了,Redis数据是存在内存中的，内存的寻址速度是纳秒级的，所以可以极大提升响应速度，同时缓解数据库压力。</p>
<h2 id="Redis是单线程的，为什么这么快"><a href="#Redis是单线程的，为什么这么快" class="headerlink" title="Redis是单线程的，为什么这么快?"></a>Redis是单线程的，为什么这么快?</h2><p>1、完全基于内存纳秒的访问，非常快速。<br>2、Redis中的数据结构是采用类似于java中HashMap的数据结构 Dict，底层用数组加链表实现的哈希表，可以实现查找和操作O(1)时间复杂度；<br>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>4、使用多路 I/O 复用模型，非阻塞 IO；</p>
<h2 id="Redis有哪些数据类型及应用场景？"><a href="#Redis有哪些数据类型及应用场景？" class="headerlink" title="Redis有哪些数据类型及应用场景？"></a>Redis有哪些数据类型及应用场景？</h2><p>Redis的数据结构有:<br>1.STRING字符串:可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID<br>2.哈希表:可以用来存储一些key-value对，更适合用来存储对象<br>3，LIST列表:Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据<br>4、SET集合:和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能<br>5.SORTED SET有序集合:集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</p>
<p>bitmap：布隆过滤器<br>GeoHash:坐标，借助Sorted Set实现，通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标<br>HyperLogLog:统计不重复数据，用于大数据基数统计<br>Streams:内存版的kafka</p>
<p>场景：<br>1.缓存<br>将热点数据放到内存中，提升访问速度，缓解DB压力。<br>2.计数器<br>3.分布式ID生成<br>4.海量数据统计<br>通过位图（bitmap）:存储是否参过某次活动，是否已读谋篇文章，用户是否为会员，日活统计，使用setbit和bitcount实现。<br>5.分布式队列/阻塞队列<br>List是一个双向链表，可以通过 lpush/rpush 和 rpop/lpop 写入和读取消息。<br>可以通过使用brpop/blpop 来实现阻塞队列。<br>6.分布式锁实现<br>在分布式场景下，无法使用基于进程的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的SETNX命令实现分布式锁。<br>7.热点数据存储<br>最新评论，最新文章列表，使用list 存储,ltrim取出热点数据，删除老数据。<br>8.排行榜<br>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="Redis有哪些持久化方式？各自的优缺点？"><a href="#Redis有哪些持久化方式？各自的优缺点？" class="headerlink" title="Redis有哪些持久化方式？各自的优缺点？"></a>Redis有哪些持久化方式？各自的优缺点？</h2><p>1.RDB<br>配置文件里有对应的配置信息，它持久化是会fork一个跟原进程数据一样的子进程，将数据写入一个临时文件，待持久化结束就会替换上次持久化的文件，整个过程主进程不进行任何的I/O操作，确保了它的性能。<br>bgsave命令是手动持久化也是要fork子进程进行。<br>save命令是主进程持久化，会有阻塞影响性能。<br>shutdown命令如果没有开启AOF会触发持久化操作。<br>flushall命令也会触发RDB持久化。</p>
<p>缺点：它的默认配置或自定义配置，是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，会消耗比较大的内存空间。</p>
<p>2.AOF<br>AOF是通过记录操作命令来记录数据的，只针对增删改命令操作会记录写入aof缓冲区，根据用户配置的同步硬盘策略写入<br>aof文件中，可以通过 appendfsync 参数配置同步策略。<br>优点：数据丢失少，aof持久化可以配置appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。<br>缺点：数据集大的时候，比 rdb 启动效率低。</p>
<h2 id="AOF重写机制是什么？"><a href="#AOF重写机制是什么？" class="headerlink" title="AOF重写机制是什么？"></a>AOF重写机制是什么？</h2><p>随着命令得不断写入AOF，文件会越来越大，为了解决这个问题Redis引入了AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。AOF重写机制可以通过手动触发和自动触发。</p>
<h2 id="Redis是如何处理过期数据的？"><a href="#Redis是如何处理过期数据的？" class="headerlink" title="Redis是如何处理过期数据的？"></a>Redis是如何处理过期数据的？</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间（EXPIRE和SETEX指令）。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。<br>惰性过期:不主动删除过期的键值，只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<p>定期过期:每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)<br>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h2 id="Redis内存淘汰策略？"><a href="#Redis内存淘汰策略？" class="headerlink" title="Redis内存淘汰策略？"></a>Redis内存淘汰策略？</h2><p>常见的缓存淘汰算法<br>FIFO(FirstInFirst Out，队列先进先出)，根据缓存被存储的时间，离当前最远的数据优先被淘汰;<br>LRU(Least RecentlyUsed，最近最少使用)，根据最近被使用的时间，离当前最远的数据优先被淘汰;<br>LFU(LeastFrequentlyUsed，最不经常使用)，在一段时间内，缓存数据被使用次数最少的会被淘汰。<br>当Redis内存不够用时，Redis 服务器会根据服务器设置的淘汰策略，删除一些不常用的数据，以保证 Redis 服务器的顺利运行。</p>
<p>六种淘汰策略<br>1.noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）<br>2.allkeys-lru：从所有key中使用LRU算法进行淘汰（LRU算法：即最近最少使用算法）<br>3.volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰<br>4.allkeys-random：从所有key中随机淘汰数据<br>5.volatile-random：从设置了过期时间的key中随机淘汰<br>6.volatile-ttl：在设置了过期时间的key中，淘汰过期时间剩余最短的</p>
<p>当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。<br>Redis 4.0 版本中又新增了 2 种淘汰策略：<br>volatile-lfu，淘汰所有设置了过期时间的键值中最少使用的键值；<br>allkeys-lfu，淘汰整个键值中最少使用的键值。<br>内存淘汰策略可以通过配置文件来修改，redis.conf 对应的配置项是“maxmemory-policy noeviction”，只需要把它修改成我们需要设置的类型即可</p>
<h2 id="缓存穿透、缓存击穿、缓存雪崩分别是什么？"><a href="#缓存穿透、缓存击穿、缓存雪崩分别是什么？" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩分别是什么？"></a>缓存穿透、缓存击穿、缓存雪崩分别是什么？</h2><p>缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问Mysql。</p>
<p>1.缓存雪崩:如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段。</p>
<p>2.缓存击穿:和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间。</p>
<p>3.缓存穿透:假如某一时刻访问redis的大量key都在redis中不存在(比如黑客故意伪造一些乱七八糟的key,这key压根不存在)，那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key。</p>
<h2 id="Redis和Mysql如何保证数据一致"><a href="#Redis和Mysql如何保证数据一致" class="headerlink" title="Redis和Mysql如何保证数据一致"></a>Redis和Mysql如何保证数据一致</h2><p>1.先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致。<br>2．先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中<br>3，延时双删，步骤是:先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致。</p>
<h2 id="Redis事务？"><a href="#Redis事务？" class="headerlink" title="Redis事务？"></a>Redis事务？</h2><p>它保证了语意ACID四大特性，但是对于原子性没有回滚操作，原子性，要么一起执行要么都不执行，一致性，执行一半停止了数据会恢复，持久性，本身提供了RDB和AOF，隔离性，单线程执行，没有可见性问题。<br>提供watch命令监控key，发生变化会取消事务。<br>1.事务开始<br>watch监控，执行MULTI命令，打开REDIS-MULTI标识<br>2.命令入队<br>如果客户端发送过来WATCH（乐观锁，有变动事务不会执行，监控持续到EXEC命令） MULTI（用于开启一个事务） EXEC（按照先后顺序执行事务块内命令） DISCARD（清空事务队列，放弃执行事务）命令会立即执行，其他的命令会先检查格式，不对就REDIS-MULTI标识关闭，再返回错误信息到客户端，正确就进入队列（FIFO）等待执行<br>3.事务执行<br>客户端发生EXEC命令执行<br>unwatch命令取消对所有key的监控。</p>
<h2 id="Redis分布式锁底层是如何实现的"><a href="#Redis分布式锁底层是如何实现的" class="headerlink" title="Redis分布式锁底层是如何实现的?"></a>Redis分布式锁底层是如何实现的?</h2><p>1.首先利用setnx来保证:如果key不存在才能获取到锁，如果key存在，则获取不到锁<br>2.然后还要利用lua脚本来保证多个redis操作的原子性<br>3，同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约<br>4.同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获<br>取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到.</p>
<h2 id="Redis主从复制的核心原理是什么？"><a href="#Redis主从复制的核心原理是什么？" class="headerlink" title="Redis主从复制的核心原理是什么？"></a>Redis主从复制的核心原理是什么？</h2><p>master节点：读和写<br>slaveof节点：只读</p>
<p>通过执行slaveof命令或设置slaveof选项，让一个服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。<br>全量复制:<br>(1)主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的<br>(2)主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗<br>(3)从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令;如果从节点执行bgrewriteaof，也会带来额外的消耗<br>部分复制:<br>1.复制偏移量:执行复制的双方，主从节点，分别会维护一个复制偏移量offset<br>2.复制积压缓冲区:主节点内部维护了一个固定长度的、先进先出(FIFO)队列作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。<br>3.服务器运行ID(runid):每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度:<br>。如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况);<br>。如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。<br><img src="/images/Redis%E4%B8%BB%E4%BB%8E.png"></p>
<h2 id="布隆过滤器（bitmap）原理，优缺点"><a href="#布隆过滤器（bitmap）原理，优缺点" class="headerlink" title="布隆过滤器（bitmap）原理，优缺点"></a>布隆过滤器（bitmap）原理，优缺点</h2><p>位图:int[10]，每个int类型的整数是4*8=32个bit，则int[10]一共有320 bit，每个bit非0即1，初始化时都是0<br>添加数据时，将数据进行hash得到hash值，对应到bit位，将该bit改为1，hash函数可以定义多个，则一个数据添加会将多个(hash函数个数)bit改为1，多个hash函数的目的是减少hash碰撞的概率<br>查询数据:hash函数计算得到hash值，对应到bit中，如果有一个为0，则说明数据不在bit中，如果都为1，则该数据可能在bit中<br>优点:<br>●占用内存小<br>●增加和查询元素的时间复杂度为:O(K),(K为哈希函数的个数，一般比较小)，与数据量大小无关<br>●哈希函数相互之间没有关系，方便硬件并行运算<br>●布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势<br>●数据量很大时，布隆过滤器可以表示全集<br>。使用同一组散列函数的布隆过滤器可以进行交、并、差运算<br>缺点:<br>误判率，即存在假阳性(False Position)，不能准确判断元索是否在集合中<br>不能获取元素本身<br>重启就会丢失，维护麻烦，不支持删除，数据会一直存在，误判率可以自己定，误判率越低，消耗越高，hash函数个数越多，误判率就越低，数组长度越大，误判率就越低。</p>
<h2 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h2><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使<br>用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个<br>CPU，你可以考虑一下分片（shard）。</p>
<h2 id="Redis分片有什么缺点？"><a href="#Redis分片有什么缺点？" class="headerlink" title="Redis分片有什么缺点？"></a>Redis分片有什么缺点？</h2><p>1.涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他<br>们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使<br>用交集指令）。<br>2.同时操作多个key,则不能使用Redis事务.<br>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集<br>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不<br>同的Redis实例和主机同时收集RDB / AOF文件。</p>
<h2 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a>Redis集群策略</h2><p>Redis提供了三种集群策略:<br>1.主从模式:这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要手动修改IP，另外，这种模式也比较难进行扩蓉，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量<br>2.哨兵模式:这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为进的主库，另外哨兵也可以做集群，从而可以保证但某一个哨兵节点宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证Redis集群的高可用，但是仍然不能很好的解决Redis的容量上限问题。（故障转移期间不可用）<br>3.Cluster模式:Cluster模式是用得比较多的模式，Redis3.0版本才正式提供，它支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使得整个集群支持更大的数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从它的从节点中选举一个新的主节点。<br>对于这三种模式，如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，那么选择Cluster模式</p>
<h2 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h2><h2 id="在集群模式下，redis-的-key-是如何寻址的？"><a href="#在集群模式下，redis-的-key-是如何寻址的？" class="headerlink" title="在集群模式下，redis 的 key 是如何寻址的？"></a>在集群模式下，redis 的 key 是如何寻址的？</h2><p>每个服务器都会维护一个 slot表，对应了每个 slot 真实的物理节点，当服务器<br>收到命令时，会对 key进行 crc16 进行哈希，得到哈希值 后，对 16384 进行取<br>模，取模的值就是key 对应的slot，如果 这个slot 是由当前服务器处理，则直接<br>继续执行命令，如果不是由当前节点处理，则返回该slot 对应的服务器节点地<br>址，由客户端重写请求对应的地址。</p>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用keys指令可以扫出指定模式的key列表。由于redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code快捷键</title>
    <url>/2023/10/21/VS-Code%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>VS Code快捷键</p>
<span id="more"></span>

<p>1、控制台终端显示与隐藏：ctrl + ~</p>
<p>2、打开当前目录的cmd窗口: ctrl+shift+c</p>
<p>3、打开一个新窗口：​​Ctrl+Shift+N​​</p>
<p>4、关闭VS Code：​​Ctrl+Shift+W​​</p>
<p>5、新建文件：​​Ctrl+N​​</p>
<p>6、文件之间切换​：​Ctrl+Tab​​</p>
<p>7、切出一个新的编辑器（最多​​3​​​ 个）​​Ctrl+\​​​，也可以按住​​Ctrl​​​，然后鼠标双击​​Explorer​​里的文件名，双击一个出现一个。</p>
<p>8、终端停止运行：ctrl+c</p>
<p>Java基础资料链接：<a href="https://pan.baidu.com/s/1kDHPCOn7BIW-w61AMDo4TQ#list/path=%2F">https://pan.baidu.com/s/1kDHPCOn7BIW-w61AMDo4TQ#list/path=%2F</a><br>提取码： kzha</p>
]]></content>
      <categories>
        <category>VS Code</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo安装</title>
    <url>/2022/01/14/hexo%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<span id="more"></span>

<h2 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1.安装Hexo"></a>1.安装Hexo</h2><h3 id="1-1-安装前提"><a href="#1-1-安装前提" class="headerlink" title="1.1 安装前提"></a>1.1 安装前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：<br><a href="https://nodejs.org/en/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br><a href="http://git-scm.com/">Git</a><br>如果您的电脑中已经安装上述必备程序，可以直接到安装 Hexo 步骤。<br>安装好后可以测试下输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>命令回车结果<br><img src="/images/node1.png"></p>
<h3 id="1-2-Node-js-版本限制"><a href="#1-2-Node-js-版本限制" class="headerlink" title="1.2 Node.js 版本限制"></a>1.2 Node.js 版本限制</h3><table>
<thead>
<tr>
<th>Hexo 版本</th>
<th>最低兼容 Node.js 版本</th>
</tr>
</thead>
<tbody><tr>
<td>6.0+</td>
<td>12.13.0</td>
</tr>
<tr>
<td>5.0+</td>
<td>10.13.0</td>
</tr>
<tr>
<td>4.2-4.2</td>
<td>8.10</td>
</tr>
</tbody></table>
<h3 id="1-3-安装-Hexo"><a href="#1-3-安装-Hexo" class="headerlink" title="1.3 安装 Hexo"></a>1.3 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<br>Windows电脑下面命令复制去掉$</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>验证hexo安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/hexo1.png"></p>
<p>安装 Hexo 完成后，在我们想要放hexo的终端目录执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>启动，进入我们hexo根目录，也就是上面的folder，按照以下命令</p>
<table>
<thead>
<tr>
<th>Hexo 版本</th>
<th>最低兼容 Node.js 版本</th>
</tr>
</thead>
<tbody><tr>
<td>hexo generate</td>
<td>生成静态文件，可以简写hexo g</td>
</tr>
<tr>
<td>hexo server</td>
<td>启动服务器，-p可以指定启动端口,可以简写hexo s</td>
</tr>
<tr>
<td>hexo deploy</td>
<td>部署网站，这里我后面结合git使用，部署之前预先生成静态文件,可以简写hexo d</td>
</tr>
<tr>
<td>hexo clean</td>
<td>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，用浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a></p>
<h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h2><p>部署到我们的github上，通过访问我们的github pag来看我们的博客</p>
<h4 id="1-设置Git的user-name和email"><a href="#1-设置Git的user-name和email" class="headerlink" title="1. 设置Git的user name和email"></a>1. 设置Git的user name和email</h4><p>在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-SSH-授权"><a href="#2-SSH-授权" class="headerlink" title="2. SSH 授权"></a>2. SSH 授权</h4><p>打开git bash，输入<br>ssh-keygen -t rsa, 接着回车三下，最后得到了两个文件：id_rsa和id_rsa.pub。<br>文件在我们C盘-&gt;用户文件夹-&gt;用户名下面，是一个.ssh隐藏文件夹，如果看不到隐藏项目，请在查看里面勾选隐藏项目，具体看图<br><img src="/images/ssh.png"></p>
<h4 id="3-部署到github"><a href="#3-部署到github" class="headerlink" title="3. 部署到github"></a>3. 部署到github</h4><p>登录我们的github，为我们的博客创建一个仓库，仓库名字为 username.github.io,username为自定义名字，等上传成功后可通过<a href="https://langallover.github.io/">https://LangAllover.github.io/</a> 访问自己的博客（这里用我的演示）<br><img src="/images/boke.png"></p>
<p>通过hexo上传到github，需要hexo-deployer-git插件，安装插件<br>在我们的hexo根目录安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>打开hexo根目录路径下配置文件_config.yml修改deploy参数<br>ctrl +f搜索deploy然后修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:LangAllover/LangAllover.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>在终端输入命令创建一篇新博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;博客名&quot;</span></span><br></pre></td></tr></table></figure>
<p>这时文件夹source/_posts文件夹里会出现博客名.md的博客文章源文件文件是markdown格式，有一套语法规范，后面文章会说到。</p>
<p>本来现在只需要hexo d -g命令直接部署到我们github就行，下面是把换主题一起说明。<br>这个时候我们的博客是hexo默认主题，我有个仓库放了hexo-theme-next主题，本篇文章也是基于我这边版本主题来的。<br><img src="/images/hexo2.png" alt="默认主题"></p>
<p>在我们的hexo根目录下,终端输入命令回车</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/LangAllover/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<p>我们的themes目录就是专门放我们主题的，这时候next主题就clone到我们本地了，然后我们在hexo根目录下的_config.yml文件下ctrl+f搜索theme修改如下<br><img src="/images/hexo-next.png"></p>
<p>后面就可以本地启动访问看下，确认是变成next主题就可以部署到github上<br>在hexo根目录下终端输入，可以简写命令一起用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>先生成静态文件然后部署<br>或者用下面这个，效果一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<p>发布上去后就可以看到我们的next主题，这时我们可以访问我们之前的仓库链接看效果<br><a href="https://langallover.github.io/">https://LangAllover.github.io/</a> </p>
<p><img src="/images/hexo-ok.png"></p>
<p>Hexo命令和详细说明请点击-&gt;<a href="https://hexo.io/zh-cn/docs/">官方详情文档</a>，以上是本人使用过程中用到的。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程&amp;并发</title>
    <url>/2023/02/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>Java中实现多线程有几种方法？</p>
<span id="more"></span>
<p>继承Thread类；<br>实现Runnable接口；<br>实现Callable接口通过FutureTask包装器来创建Thread线程；<br>使用ExecutorService、Callable、Future实现有返回结果的多线程（也就是使用了ExecutorService来管理前面的三种方式）。</p>
<p>如何停止一个正在运行的线程？<br>1、使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>2、使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。<br>3、使用interrupt方法中断线程。</p>
<p>在Eureka架构中，微服务角色有两类:<br>●EurekaServer:服务端，注册中心<br>记录服务信息<br>◆心跳监控<br>●EurekaClient:客户端<br>◆Provider:服务提供者，例如案例中的user-service<br>◆注册自己的信息到EurekaServer<br>每隔3O秒向EurekaServer发送心跳<br>◆consumer:服务消费者，例如案例中的order-service<br>◆根据服务名称从EurekaServer拉取服务列表<br>基于服务列表做负载均衡，选中一个微服务后发起远<br>程调用</p>
<p>1.搭建EurekaServer<br>引入eureka-server依赖<br>添加@EnableEurekaServer注解<br>在application.yml中配置eureka地址</p>
<p>2.服务注册<br>引入eureka-client依赖<br>在application.yml中配置eureka地址</p>
<p>3.服务发现<br>引入eureka-client依赖<br>在application.yml中配置eureka地址<br>给RestTemplate添加@LoadBalanced注解（负载均衡）<br>用服务提供者的服务名称远程调用</p>
<p>Nacos比Eureka好用（还有Consul）<br>Nacos是阿里巴巴的产品，现在是springCloud的一个组件，相对Eureka功能更丰富</p>
<p>项目技术：springCloud、Nacos注册中心、Feign远程调用、Ribbon做负载均衡</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows之常用命令</title>
    <url>/2023/10/21/%E5%B8%B8%E7%94%A8%E7%9A%84DOS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在Windows系统中，可以使用多种命令来杀死（结束）进程。以下是几种常用的方法：</p>
<span id="more"></span>

<p>1、使用任务管理器：</p>
<p>快捷键：Ctrl + Shift + Esc 或 Ctrl + Alt + Delete 然后选择“任务管理器”。<br>在任务管理器中，找到“进程”标签页，选中想要结束的进程，然后点击“结束任务”按钮。<br>使用命令提示符（cmd）：</p>
<p>2、打开命令提示符，输入以下命令查看所有进程及其PID：<br>tasklist<br>使用taskkill命令强制结束指定进程，例如结束PID为1234的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /PID 1234</span><br></pre></td></tr></table></figure>


<p>3、使用Windows PowerShell：</p>
<p>打开PowerShell，输入以下命令查看所有进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Get-Process</span><br></pre></td></tr></table></figure>

<p>使用Stop-Process命令强制结束指定进程，可以通过进程ID或进程名称来指定。例如，结束进程名称为notepad的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stop-Process -Name notepad -Force</span><br></pre></td></tr></table></figure>


<p>4、根据端口号结束进程：</p>
<p>首先使用netstat命令查找占用端口的进程ID，例如查找端口8081对应的进程ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :8081</span><br></pre></td></tr></table></figure>

<p>然后使用taskkill命令结束该进程，例如结束PID为50908的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /PID 50908 /F</span><br></pre></td></tr></table></figure>

<p>5、使用批处理脚本：</p>
<p>可以编写批处理脚本来批量结束进程。例如，结束所有名为redis-server.exe的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /IM redis-server.exe /T</span><br></pre></td></tr></table></figure>

<p>请注意，强制结束进程可能会导致数据丢失或系统不稳定，因此请谨慎操作，并确保不会误关重要的系统进程或服务。</p>
<p>常用的DOS命令<br>1.切换盘符：盘符名加冒号，回车</p>
<p>2.退出到当前目录的根目录：cd (change directory)</p>
<p>3.退回到上一层目录：cd ..</p>
<p>4.进入某个目录：cd 目录名</p>
<p>5.列出目录下的内容：dir</p>
<p>6.创建文件夹：md 目录名(make directory)</p>
<p>7.创建文件并写入内容：<br>echo 内容&gt;文件名<br>追加内容<br>echo 内容&gt;&gt;文件名</p>
<p>8.删除文件：<br>del 文件名(delete)</p>
<p>9.删除文件夹<br>rmdir 目录名，删除空目录(remove directory)（只能删除空的文件夹）</p>
<p>10.清屏：cls</p>
<p>11.查看ip地址ipconfig</p>
<ol start="12">
<li>测试网络是否连通ping</li>
</ol>
<p>13.退出：exit</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-CAS&amp;Atomic原子操作详解</title>
    <url>/2022/03/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CAS&amp;Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>CAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == expectedValue) &#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上伪代码描述了一个由比较和赋值两阶段组成的复合操作，CAS 可以看作是它们合并后的整体——一个不可分割的原子操作，并且其原子性是直接在硬件层面得到保障的。<br>CAS可以看做是乐观锁（对比数据库的悲观、乐观锁）的一种实现方式，Java原子类中的递增操作就通过CAS自旋实现的。CAS是一种无锁算法，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p>
<p>CAS 操作是由 Unsafe 类提供支持的，该类定义了三种针对不同类型变量的 CAS 操作.</p>
<p>unsafe.png</p>
<p>它们都是 native 方法，由 Java 虚拟机提供具体实现，这意味着不同的 Java 虚拟机对它们的实现可能会略有不同。<br>以 compareAndSwapInt 为例，Unsafe 的 compareAndSwapInt 方法接收 4 个参数，分别是：对象实例、内存偏移量、字段期望值、字段新值。该方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import javax.swing.text.html.parser.Entity;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class CASTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Entity entity = new Entity(<span class="string">&quot;x&quot;</span>,0,null);</span><br><span class="line"></span><br><span class="line">        Unsafe unsafe = UnsafeFactory.getUnsafe();</span><br><span class="line"></span><br><span class="line">        long offset = UnsafeFactory.getFieldOffset(unsafe, Entity.class, <span class="string">&quot;type&quot;</span>);</span><br><span class="line"></span><br><span class="line">        boolean successful;</span><br><span class="line"></span><br><span class="line">        // 4个参数分别是：对象实例、字段的内存偏移量、字段期望值、字段新值</span><br><span class="line">        successful = unsafe.compareAndSwapInt(entity, offset, 0, 3);</span><br><span class="line">        System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.type);</span><br><span class="line"></span><br><span class="line">        successful = unsafe.compareAndSwapInt(entity, offset, 3, 5);</span><br><span class="line">        System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.type);</span><br><span class="line"></span><br><span class="line">        successful = unsafe.compareAndSwapInt(entity, offset, 3, 8);</span><br><span class="line">        System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class UnsafeFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取Unsafe 对象</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static Unsafe <span class="function"><span class="title">getUnsafe</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">return</span> (Unsafe) field.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取字段的内存偏移量</span><br><span class="line">     * @param unsafe</span><br><span class="line">     * @param clazz</span><br><span class="line">     * @param fieldName</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static long getFieldOffset(Unsafe unsafe, Class clazz, String fieldName) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             <span class="built_in">return</span> unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName));</span><br><span class="line">             &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">             throw new Error(e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entity.type 的 3 次 CAS 操作，分别试图将它从 0 改成 3、从 3 改成 5、从 3 改成 8。执行结果如下：<br>true    3<br>true    5<br>false    5</p>
<p>CAS缺陷<br>CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：</p>
<ul>
<li>自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销</li>
<li>只能保证一个共享变量原子操作</li>
<li>ABA 问题<br>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</li>
</ul>
<p>什么是ABA问题<br>当有多个线程对一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，此时其他线程不感知，还是会修改成功。<br>ABA.png</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ABATest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         AtomicInteger atomicInteger = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">         new Thread(()-&gt;&#123;</span><br><span class="line">                 int value = atomicInteger.get();</span><br><span class="line">             System.out.println(&quot;Thread1 read value: &quot; + value);</span><br><span class="line"></span><br><span class="line">         // 阻塞1s</span><br><span class="line">         LockSupport.parkNanos(1000000000L);</span><br><span class="line"></span><br><span class="line">         // Thread1通过CAS修改value值为3</span><br><span class="line">         if (atomicInteger.compareAndSet(value, 3)) &#123;</span><br><span class="line">             System.out.println(&quot;Thread1 update from &quot; + value + &quot; to 3&quot;);</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">             System.out.println(&quot;Thread1 update fail!&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,&quot;Thread1&quot;).start();</span><br><span class="line"></span><br><span class="line">         new Thread(()-&gt;&#123;</span><br><span class="line">                 int value = atomicInteger.get();</span><br><span class="line">             System.out.println(&quot;Thread2 read value: &quot; + value);</span><br><span class="line">         // Thread2通过CAS修改value值为2</span><br><span class="line">         if (atomicInteger.compareAndSet(value, 2)) &#123;</span><br><span class="line">             System.out.println(&quot;Thread2 update from &quot; + value + &quot; to 2&quot;);</span><br><span class="line">             </span><br><span class="line">             value = atomicInteger.get();</span><br><span class="line">             System.out.println(&quot;Thread2 read value: &quot; + value);</span><br><span class="line">             // Thread2通过CAS修改value值为1</span><br><span class="line">             if (atomicInteger.compareAndSet(value, 1)) &#123;</span><br><span class="line">                 System.out.println(&quot;Thread2 update from &quot; + value + &quot; to 1&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,&quot;Thread2&quot;).start();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Thread1 read value: 1<br>Thread2 read value: 1<br>Thread2 update from 1 to 2<br>Thread2 read value: 2<br>Thread2 update from 2 to 1<br>Thread1 update from 1 to 3<br>Thread1不清楚Thread2对value的操作，误以为value=1没有修改过，但是我们对原值是只能有一次修改的这个前提，那么按理Thread2 update from 2 to 1应该是要失败的</p>
<p>ABA问题的解决方案<br>数据库有个锁称为乐观锁，是一种基于数据版本实现数据同步的机制(加个版本号)，每次修改一次数据，版本就会进行累加。<br>同样，Java也提供了相应的原子引用类AtomicStampedReference<V><br>AtomicStampedReference.png<br>reference即我们实际存储的变量，stamp是版本，每次修改可以通过+1保证版本唯一性。这样就可以保证每次修改后的版本也会往上递增。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AtomicStampedReferenceTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         // 定义AtomicStampedReference Pair.reference值为1, Pair.stamp为1</span><br><span class="line">         AtomicStampedReference atomicStampedReference = new</span><br><span class="line">                AtomicStampedReference(1,1);</span><br><span class="line"></span><br><span class="line">         new Thread(()-&gt;&#123;</span><br><span class="line">             int[] stampHolder = new int[1];</span><br><span class="line">             int value = (int) atomicStampedReference.get(stampHolder);</span><br><span class="line">         int stamp = stampHolder[0];</span><br><span class="line">             System.out.println(<span class="string">&quot;Thread1 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">         // 阻塞1s</span><br><span class="line">         LockSupport.parkNanos(1000000000L);</span><br><span class="line">         // Thread1通过CAS修改value值为3</span><br><span class="line">         <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, 3,stamp,stamp+1)) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Thread1 update from &quot;</span> + value + <span class="string">&quot; to 3&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Thread1 update fail!&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,<span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">         new Thread(()-&gt;&#123;</span><br><span class="line">                 int[] stampHolder = new int[1];</span><br><span class="line">         int value = (int)atomicStampedReference.get(stampHolder);</span><br><span class="line">         int stamp = stampHolder[0];</span><br><span class="line">             System.out.println(<span class="string">&quot;Thread2 read value: &quot;</span> + value+ <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">         // Thread2通过CAS修改value值为2</span><br><span class="line">         <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, 2,stamp,stamp+1)) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Thread2 update from &quot;</span> + value + <span class="string">&quot; to 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">             value = (int) atomicStampedReference.get(stampHolder);</span><br><span class="line">             stamp = stampHolder[0];</span><br><span class="line">             System.out.println(<span class="string">&quot;Thread2 read value: &quot;</span> + value+ <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">             // Thread2通过CAS修改value值为1</span><br><span class="line">             <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, 1,stamp,stamp+1)) &#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;Thread2 update from &quot;</span> + value + <span class="string">&quot; to 1&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,<span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Thread1 read value: 1, stamp: 1<br>Thread2 read value: 1, stamp: 1<br>Thread2 update from 1 to 2<br>Thread2 read value: 2, stamp: 2<br>Thread2 update from 2 to 1<br>Thread1 update fail!</p>
<p>注意：AtomicMarkableReference可以理解为上面AtomicStampedReference的简化版，就是不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改<br>AtomicMarkableReference.png</p>
<p>Atomic原子操作类介绍</p>
<p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
<p>在java.util.concurrent.atomic包里提供了一组原子操作类：</p>
<ul>
<li>基本类型：AtomicInteger、AtomicLong、AtomicBoolean；</li>
<li>引用类型：AtomicReference、AtomicStampedRerence、AtomicMarkableReference；</li>
<li>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</li>
<li>对象属性原子修改器：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、</li>
<li>AtomicReferenceFieldUpdater原子类型累加器（jdk1.8增加的类）：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64<br>Antomic.png</li>
</ul>
<p>常用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//以原子的方式将实例中的原值加1，返回的是自增前的旧值；</span><br><span class="line">       public final int <span class="function"><span class="title">getAndIncrement</span></span>() &#123;</span><br><span class="line">       <span class="built_in">return</span> unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">       &#125;</span><br><span class="line">       //getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值；</span><br><span class="line">       public final boolean getAndSet(boolean newValue) &#123;</span><br><span class="line">       boolean prev;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           prev = get();</span><br><span class="line">           &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">       <span class="built_in">return</span> prev;</span><br><span class="line">       &#125;</span><br><span class="line">       //incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；</span><br><span class="line">           public final int <span class="function"><span class="title">incrementAndGet</span></span>() &#123;</span><br><span class="line">       <span class="built_in">return</span> unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">       &#125;</span><br><span class="line">       //addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；</span><br><span class="line">       public final int addAndGet(int delta) &#123;</span><br><span class="line">       <span class="built_in">return</span> unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerTest &#123;</span><br><span class="line">        //incrementAndGet()方法通过CAS自增实现，如果CAS失败，自旋直到成功+1。下面源码</span><br><span class="line">//    public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">//        int var5;</span><br><span class="line">//        <span class="keyword">do</span> &#123;</span><br><span class="line">//            var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">//        &#125; <span class="keyword">while</span>(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">//</span><br><span class="line">//        <span class="built_in">return</span> var5;</span><br><span class="line">//    &#125;</span><br><span class="line">    static AtomicInteger sum = new AtomicInteger(0);</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">for</span> (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">                // 原子自增 CAS</span><br><span class="line">                sum.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(sum.get());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：100000</p>
<p>原子更新数组类型<br>AtomicIntegerArray为例总结常用的方法</p>
<p>//addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；<br>        public final int addAndGet(int i, int delta) {<br>            return getAndAdd(i, delta) + delta;<br>        }<br>         //getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1；<br>         public final int getAndIncrement(int i) {<br>         return getAndAdd(i, 1);<br>         }<br>        //compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更新<br>        public final boolean compareAndSet(int i, int expect, int update) {<br>        return compareAndSetRaw(checkedByteOffset(i), expect, update);<br>        }</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerArrayTest &#123;</span><br><span class="line">    static int[] value = new int[]&#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">    static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(value);</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    //设置索引0的元素为100</span><br><span class="line">    atomicIntegerArray.set(0, 100);</span><br><span class="line">    System.out.println(atomicIntegerArray.get(0));</span><br><span class="line">    //以原子更新的方式将数组中索引为1的元素与输入值相加</span><br><span class="line">    atomicIntegerArray.getAndAdd(1,5);</span><br><span class="line">    System.out.println(atomicIntegerArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//结果</span><br><span class="line">//100</span><br><span class="line">//[100, 7, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>原子更新引用类型<br>AtomicReference作用是对普通对象的封装，它可以保证你在修改对象引用时的线程安全性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        User user1 = new User(<span class="string">&quot;张三&quot;</span>,23);</span><br><span class="line">        User user2 = new User(<span class="string">&quot;李四&quot;</span>,25);</span><br><span class="line">        User user3 = new User(<span class="string">&quot;王五&quot;</span>,20);</span><br><span class="line">        //初始化为 user1</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;();</span><br><span class="line">        atomicReference.set(user1);</span><br><span class="line">        //把 user2 赋给 atomicReference</span><br><span class="line">        atomicReference.compareAndSet(user1, user2);</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">        //把 user3 赋给 atomicReference</span><br><span class="line">        atomicReference.compareAndSet(user1, user3);</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public User(String name, Integer age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>com.study.User@1fb3ebeb<br>com.study.User@1fb3ebeb</p>
<p>对象属性原子修改器<br>AtomicIntegerFieldUpdater可以线程安全地更新对象中的整型变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterTest &#123;</span><br><span class="line"></span><br><span class="line">    public static class Candidate &#123;</span><br><span class="line">        volatile int score = 0;</span><br><span class="line">        AtomicInteger score2 = new AtomicInteger();</span><br><span class="line">    &#125;</span><br><span class="line">    public static final AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =</span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line">    public static AtomicInteger realScore = new AtomicInteger(0);</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Candidate candidate = new Candidate();</span><br><span class="line">        Thread[] t = new Thread[10000];</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            t[i] = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.random() &gt; 0.4) &#123;</span><br><span class="line">                    candidate.score2.incrementAndGet();</span><br><span class="line">                    scoreUpdater.incrementAndGet(candidate);</span><br><span class="line">                    realScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicIntegerFieldUpdater Score=&quot;</span> + candidate.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger Score=&quot;</span> + candidate.score2.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;realScore=&quot;</span> + realScore.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>AtomicIntegerFieldUpdater Score=5957<br>AtomicInteger Score=5957<br>realScore=5957</p>
<p>对于AtomicIntegerFieldUpdater 的使用稍微有一些限制和约束，约束如下：<br>（1）字段必须是volatile类型的，在线程之间共享变量时保证立即可见.eg:volatile int value = 3<br>（2）字段的描述类型（修饰符public/protected/default/private）与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。<br>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。<br>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。<br>（5）对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</p>
<p>LongAdder/DoubleAdder详解<br>AtomicLong是利用了底层的CAS操作来提供并发性的，比如addAndGet方法：<br>AtomicLong.png<br>上述方法调用了Unsafe类的getAndAddLong方法，该方法内部是个native方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。<br>在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时AtomicLong的自旋会成为瓶颈。这就是LongAdder引入的初衷——解决高并发环境下AtomicInteger，AtomicLong的自旋瓶颈问题。</p>
<p>低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那LongAdder可能更合适。<br>LongAdder原理<br>AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。LongAdder的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。<br>LongAdder.png</p>
<p>LongAdder的内部结构<br>LongAdder内部有一个base变量，一个Cell[]数组：</p>
<ul>
<li>base变量：非竞态条件下，直接累加到该变量上</li>
<li>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中<br>LongAdderClass.png</li>
</ul>
<p>定义了一个内部Cell类，这就是我们之前所说的槽，每个Cell对象存有一个value值，可以通过Unsafe来CAS操作它的值：<br>Striped64.png</p>
<pre><code>/** Number of CPUS, to place bound on table size */
// CPU核数，用来决定槽数组的大小
static final int NCPU = Runtime.getRuntime().availableProcessors();

/**
 * Table of cells. When non-null, size is a power of 2.
 */
 // 数组槽，大小为2的次幂
transient volatile Cell[] cells;

/**
 * Base value, used mainly when there is no contention, but also as
 * a fallback during table initialization races. Updated via CAS.
 */
 /** 基数，在两种情况下会使用：
* 1. 没有遇到并发竞争时，直接使用base累加数值
* 2. 初始化cells数组时，必须要保证cells数组只能被初始化一次（即只有一个线程能对cells初始化），* 其他竞争失败的线程会讲数值累加到base上*/
transient volatile long base;

/**
 * Spinlock (locked via CAS) used when resizing and/or creating Cells.
 */
transient volatile int cellsBusy;
</code></pre>
<p>LongAdder#add方法逻辑：<br>LongAdder#add.png</p>
<p>只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。<br>如果Cell[] 数组未初始化，会调用父类的longAccumelate去初始化Cell[ ].如果Cell[] 已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。<br>这也是LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-Java并发线程池底层原理详解与源码分析</title>
    <url>/2022/04/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Java%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>线程池<br>解释起来可以理解为线程缓存，不能被无限制的创建，否则不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、调优和监控</p>
<span id="more"></span>

<p>使用线程池的目的<br>当我们请求过多不断使用线程执行任务时，如果执行任务时间很短，就会造成频繁的的创建和销毁线程，可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。<br>线程池可以复用线程，而不是使用完就销毁，可以继续执行其他任务，通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。当我们有已下情况建议使用线程池；</p>
<ul>
<li>单个任务处理时间比较短</li>
<li>需要处理的任务数量很大</li>
</ul>
<p>java线程池工作流程.png</p>
<p>Executor框架<br>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p>
<p>线程池存在5种状态：</p>
<ul>
<li><p>RUNNING = ‐1 &lt;&lt; COUNT_BITS; //高3位为111，线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！</p>
</li>
<li><p>SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000，状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。<br>状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
</li>
<li><p>STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001，) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中<br>断正在处理的任务。状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
</li>
<li><p>TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010，状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING<br>状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。<br>状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
</li>
<li><p>TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为01，状态说明：线程池彻底终止，就变成TERMINATED状态。状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。<br>进入TERMINATED的条件如下：<br>线程池不是RUNNING状态；<br>线程池状态不是TIDYING状态或TERMINATED状态；<br>如果线程池状态是SHUTDOWN并且workerQueue为空；<br>workerCount为0；<br>设置TIDYING状态成功。</p>
</li>
</ul>
<p>线程池状态流程.png</p>
<p>默认线程池<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,<br>BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</p>
<p>无返回值提交：public void execute()</p>
<p>任务执行完有返回值：public Future&lt;?&gt; submit()</p>
<p>ThreadPoolExecutor方法参数：<br>corePoolSize，线程池中的核心线程数，达到这个核心数继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。<br>maximumPoolSize：线程池中允许的最大线程数，如果corePoolSize中阻塞队列满了，且继续提交任务，则创建新的线程执行任务，但是依旧要满足当前线程数小于maximumPoolSize；<br>keepAliveTime：线程池维护的线程空闲时间，当前线程执行完不会销毁会等待新提交的任务过来，在这个时间之内会一直等待，超过就不等了。<br>unit：keepAliveTime的时间单位；<br>workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：<br>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；<br>LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；<br>SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；<br>priorityBlockingQuene：具有优先级的无界阻塞队列；</p>
<p>threadFactory：用来创建新线程，默认使用Executors.defaultThreadFactory() 来创建线程。<br>handler：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<br>AbortPolicy：直接抛出异常，默认策略；<br>CallerRunsPolicy：用调用者所在的线程来执行任务；<br>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>DiscardPolicy：直接丢弃任务；<br>上面的4种策略都是ThreadPoolExecutor的内部类。</p>
<p>我们也可以根据需要自定义策略：<br>通过实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<p>Executors的创建线程池的方法，创建出来的线程池都实现了ExecutorService接口。常用方法有以下几个：<br>1.newFiexedThreadPool(int Threads)：创建固定数目线程的线程池。<br>2.newCachedThreadPool()：创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br>3.newSingleThreadExecutor()创建一个单线程化的Executor。<br>4.newScheduledThreadPool(int corePoolSize) 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
<p>执行原理<br>线程池执行器将会根据corePoolSize和maximumPoolSize自动地调整线程池大小。<br>当在execute(Runnable)方法中提交新任务并且少于corePoolSize线程正在运行时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求。 如果有多于corePoolSize但小于maximumPoolSize线程正在运行，则仅当队列已满时才会创建新线程。 通过设置corePoolSize和maximumPoolSize相同，您可以创建一个固定大小的线程池。通过将maximumPoolSize设置为基本上无界的值，例如Integer.MAX_VALUE，您可以允许池容纳任意数量的并发任务。 通常，核心和最大池大小仅在构建时设置，但也可以使用setCorePoolSize和setMaximumPoolSize进行动态更改。<br>corePoolSize线程流转图.png</p>
<p>使用 Executors 创建四种类型的线程池<br>newCachedThreadPool是Executors工厂类的一个静态函数，用来创建一个可以无限扩大的线程池。而Executors工厂类一共可以创建四种类型的线程池，通过Executors.newXXX即可创建。<br>FixedThreadPool</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads)&#123;</span><br><span class="line">    <span class="built_in">return</span> new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FixedThreadPool.png<br>它是一种固定大小的线程池；<br>corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；<br>keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效；<br>阻塞队列采用了LinkedBlockingQueue，它是一个无界队列；<br>由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；<br>由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</p>
<p>CachedThreadPool</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static ExecutorService <span class="function"><span class="title">newCachedThreadPool</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.MILLISECONDS,new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CachedThreadPool.png<br>它是一个可以无限扩大的线程池；<br>它比较适合处理执行时间比较小的任务；<br>corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大；<br>keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死；<br>采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</p>
<p>SingleThreadExecutor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static ExecutorService <span class="function"><span class="title">newSingleThreadExecutor</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleThreadExecutor.png<br>它只会创建一条工作线程处理任务；<br>采用的阻塞队列为LinkedBlockingQueue；</p>
<p>ScheduledThreadPool<br>它用来处理延时任务或定时任务。<br>ScheduledThreadPool.png<br>它接收SchduledFutureTask类型的任务，有两种提交任务的方式：<br>scheduledAtFixedRate<br>scheduledWithFixedDelay<br>SchduledFutureTask接收的参数：<br>time：任务开始的时间<br>sequenceNumber：任务的序号<br>period：任务执行的时间间隔<br>它采用DelayQueue存储等待的任务<br>DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序；<br>DelayQueue也是一个无界队列；<br>工作线程的执行过程：<br>工作线程会从DelayQueue取已经到期的任务去执行；<br>执行结束后重新设置任务的到期时间，再次放回DelayQueue</p>
<p>Executors为什么存在缺陷?<br>Java中的BlockingQueue主要有两种实现，分别是ArrayBlockingQueue 和 LinkedBlockingQueue。<br>ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。<br>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。这里的问题就出在：不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。<br>而newFixedThreadPool中创建LinkedBlockingQueue时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。<br>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。</p>
<p>正确创建线程池</p>
<p>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private static ExecutorService executor = new ThreadPoolExecutor(10, 10,</span><br><span class="line">        60L, TimeUnit.SECONDS,</span><br><span class="line">        new ArrayBlockingQueue(10));</span><br></pre></td></tr></table></figure>
<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。<br>除了自己定义ThreadPoolExecutor外。还有其他方法。这个时候第一时间就应该想到开源类库，如apache和guava等。<br>推荐使用guava提供的ThreadFactoryBuilder来创建线程池。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ExecutorsDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    private static ExecutorService pool = new ThreadPoolExecutor(5, 200,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            pool.execute(new SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>HashMap<br>数据结构：数组+链表+（jdk&gt;=8引入红黑树）<br>特点：<br>key，value存储，key可以为null，同样的key会被覆盖掉<br>原理讲解：<br>哈希算法（也叫散列），就是把任意长度值(Key)通过散列算法变换成固定长度的key（地址）<br>通过这个地址进行访问的数据结构它通过把关键码值映射到表中一个。位置来访问记录，以加<br>快查找的速度。<br>Hashcode：通过字符串算出它的ascii码，进行mod（取模），算出哈希表中的下标</p>
<p>哈希冲突<br>在向Hash表中存数据时，首先要用Hash函数计算出该数据要存放的地址。但是在这个地址中已经有值存在，所以这个时候就发生了Hash冲突。也就是一句话：key值不同的元素可能会映象到哈希表的同一地址上。</p>
<p>HashMap中如何解决Hash冲突？<br>HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它通过计算散列码来决定存储的位置，HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，出来的hash值一样，不同对象出来的hash值一样，出现所谓hash冲突，HashMap底层通过链表解决hash冲突的。<br>HashMap其实就是一个Entry数组（类似pair），Entry对象中包含了链和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。<br>在Java8之前，如果发生hash冲突往往是将该value直接链接到该位置的其他所有value的头部，即相互冲突的所有value形成一个链表，因此，最坏情况HashMap的查找时间复杂度退化到O(n)，在Java8中做了改进，一个是改头插法为尾插法，还有一个是当一个位置冲突过多时（大于等于8），存储的value将形成一排序二叉树，排序的依据为key的hashCode，这样在最坏情况下，性能也只退化到O(logn)。<br>这样的改进意义重大，一是从O(n)提升到O(logn)的时间开销（最坏情况），二是如果恶意程序知道我们利用的Hash算法，在纯链表情况下，发送大量请求导致hash碰撞，不停访问这些key使HashMap忙于查找，最终瘫痪。</p>
<p>为什么引入红黑树？<br>static final int TREEIFY_THRESHOLD = 8; 链表长度大于 红黑树，因为链表查询的时候链表过长了查询效率非常低，所以需要用红黑树</p>
<p>Hash冲突的解决方法<br>Hash冲突，也就是经过一个函数结果作为地址去存放当前key value键值对(这个是hashmap存值方式)。<br>解决hash冲突发方法有：</p>
<ul>
<li>开放地址法，这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</li>
<li>链地址法，就是key值取模再运算，java的HashMap就是这么实现的，在put()方法里面。</li>
<li>重哈希法，在创建hashmap的时候一般默认初始化容量，创建的hash表是桶的数量，负载因子：map的size/初始化容量，当hash表中负载因子达到负载极限，hash表会自动成倍增加容量，并将原有的对象重新分配加入新的值，成为rehash，rehash非常影响性能，所以初始化容量要设置好，不能太过浪费空间，也不能过小造成rehash情况经常出现。</li>
<li>建立一个公共溢出区域，这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li>
</ul>
<p>ConcurrentHashMap<br>特点：<br>并发安全的HashMap ，比Hashtable效率更高<br>存储结构：<br>底层采用数组、链表、红黑树 内部大量采用CAS操作。并发控制使⽤synchronized 和CAS 来操作来实现的。ConcurrentHashMap的数据结构与HashMap基本类似，区别在于：1、内部在数据写入时加了同步机制(分段锁)保证线程安全，读操作是无锁操作；2、扩容时老数据的转移是并发执行的，这样扩容的效率更高。</p>
<p>Java7和8对比：<a href="https://www.processon.com/view/link/625903a10791296b57b44b3b">https://www.processon.com/view/link/625903a10791296b57b44b3b</a></p>
<p>ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(putVal())的过程</p>
<ul>
<li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li>
<li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</li>
</ul>
<p>协助扩容helpTransfer:<br>1.检查是否扩容完成<br>2.对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</p>
<p>transfer进行扩容：<br>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。</p>
<p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p>
<p>Map 是一种键-值对（key-value）集合，Map 集合中的每一个元素都包含一个键（key）对象和一个值（value）对象。用于保存具有映射关系的数据。</p>
<p>Map 集合里保存着两组值，一组值用于保存 Map 里的 key，另外一组值用于保存 Map 里的 value，key 和 value 都可以是任何引用类型的数据。Map 的 key 不允许重复，value 可以重复，即同一个 Map 对象的任何两个 key 通过 equals 方法比较总是返回 false。</p>
<p>Map 中的 key 和 value 之间存在单向一对一关系，即通过指定的 key，总能找到唯一的、确定的 value。从 Map 中取出数据时，只要给出指定的 key，就可以取出对应的 value。</p>
<p>Map集合的特点:<br>1.是一个双列集合,赋值的时候必须同时给key和value赋值<br>2.是一个无序的集合(存入和取出元素的顺序可能不一致)<br>3.key值不能重复,value可以重复<br>4.一个key只能对应一个vlaue<br>5.定义集合时,数据类型key和value可以使用相同的数据类型,也可以使用不同的数据类型</p>
<p>Map 接口主要有两个实现类：HashMap 类和 TreeMap 类。其中，HashMap 类按哈希算法来存取键对象，而 TreeMap 类可以对键对象进行排序。<br>map接口.png</p>
<p>遍历Map</p>
<ol>
<li><p>使用keySet()方法遍历<br>使用keyset方法遍历，是先取出map的key组成的Set集合，通过对Set集合的遍历，然后使用map.get(key)方法取出value值。<br>for (String key : map.keySet()) {<br> System.out.println(key + “ : “ + map.get(key));<br>}</p>
</li>
<li><p>使用map的values()方法遍历集合的values<br>map.values()返回的是由map的值组成的Collection，这个方法只能遍历map的所有value，不能得到map的key。<br>for (String value : map.values()) {<br> System.out.println(value);<br>}</p>
</li>
<li><p>使用map的entrySet()方法遍历<br>使用map的entrySet()方法返回一个以Entry为元素的Set集合，然后对Set集合进行遍历。<br>for (Entry&lt;String, String&gt; entry : map.entrySet()) {<br> System.out.println(entry.getKey() + “ : “ +     entry.getValue());<br>}</p>
</li>
<li><p>通过keySet()返回的集合的iterator遍历<br>由于map.keySet()返回的是一个Set集合，所以通过它的iterator()方法返回一个迭代器，通过迭代器遍历map。<br>Iterator<String> it = map.keySet().iterator();<br>while(it1.hasNext()) {<br> String key = it1.next();<br> System.out.println(key + “ : “ + map.get(key));<br>}</p>
</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-ForkJoin工作原理分析</title>
    <url>/2022/04/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ForkJoin%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ForkJoin工作原理分析</p>
<span id="more"></span>
<p>首先要知道为什么用到ForkJoin，我们线程池的使用怎么合理的设置线程数？<br>主要的目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能。</p>
<p>线程数计算方法:<br>线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）</p>
<p>如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，线程数就随之减少。线程太多和太少都会对系统运行有影响，实际会通过监控JVM的线程情况以及CPU的负载情况，衡量应该创建的线程数，才能合理并充分利用资源。</p>
<p>分治算法<br>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。<br>分治算法的步骤如下：</p>
<ul>
<li>分解：将要解决的问题划分成若干规模较小的同类问题；</li>
<li>求解：当子问题划分得足够小时，用较简单的方法解决；</li>
<li>合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。</li>
</ul>
<p>Java 并发包里提供了一种叫做 Fork/Join 的并行计算框架，就是用来支持分治这种业务场景。</p>
<p>Fork/Join框架</p>
<p>传统线程池ThreadPoolExecutor有两个明显的缺点：</p>
<ul>
<li>无法对大任务进行拆分，对于某个任务只能由单线程执行；</li>
<li>工作线程从队列中获取任务时存在竞争情况<br>这些缺点会影响任务的执行效率，所以在Java7中引入Fork/Join框架。</li>
</ul>
<p>Fork/Join框架的核心是ForkJoinPool类，ForkJoinPool允许其他线程向它提交任务，并根据设定将这些任务拆分为粒度更细的子任务，这些子任务将由ForkJoinPool内部的工作线程来并行执行，并且工作线程之间可以窃取彼此之间的任务。<br>ForkJoinPool最适合计算密集型任务，最好是非阻塞任务。ForkJoinPool是ThreadPoolExecutor线程池的一种补充，是对计算密集型场景需求的实现。</p>
<p>Fork/Join的使用</p>
<ul>
<li>分治任务的线程池ForkJoinPool</li>
<li>分治任务ForkJoinTask</li>
</ul>
<p>ForkJoinPool是用于执行ForkJoinTask任务的执行池，通过维护一个队列数组WorkQueue[]来减少提交任务和任务线程时产生的碰撞。<br>ForkJoinPool.png</p>
<p>ForkJoinPool核心参数：<br>int parallelism：指定并行级别（parallelism level）。ForkJoinPool将根据这个设定，决定工作线程的数量。如果未设置的话，将使用Runtime.getRuntime().availableProcessors()来设置并行级别；</p>
<p>ForkJoinWorkerThreadFactory factory：ForkJoinPool在创建线程时，会通过factory来创建。注意，这里需要实现的是ForkJoinWorkerThreadFactory，而不是ThreadFactory。如果你不指定factory，那么将由默认DefaultForkJoinWorkerThreadFactory负责线程的创建工作；</p>
<p>UncaughtExceptionHandler handler：指定异常处理器，当任务在运行中出错时，将由设定的处理器处理；</p>
<p>boolean asyncMode：设置队列的工作模式：asyncMode ? FIFO_QUEUE :LIFO_QUEUE。当asyncMode为true时，将使用先进先出队列，而为false时则使用后进<br>先出的模式。</p>
<p>ForkJoinPool的提交任务方式：<br>1.提交异步执行，void没有返回值。<br>execute.png</p>
<p>2.等待并获取结果，有返回值。<br>invoke.png</p>
<p>3.提交执行任务，返回Future结果。<br>submit.png</p>
<p>ForkJoinTask<br>是ForkJoinPool的重要抽象类，定义了任务执行时的具体逻辑和拆分逻辑。ForkJoinTask继承了Future接口。</p>
<p>ForkJoinTask最核心方法：<br>1.fork()<br>提交任务，用于向当前任务所运行的线程池中提交任务。</p>
<p>2.join()<br>获取任务执行完返回的结果，调用join()时，将阻塞当前线程直到对应的子任务完成运行并返回结果。</p>
<p>使用ForkJoinTask：<br>不用继承ForkJoinTask，而是继承它的子类，有三个对应不同的场景。</p>
<ul>
<li>RecursiveAction：用于递归执行但不需要返回结果的任务。</li>
<li>RecursiveTask ：用于递归执行需要返回结果的任务。</li>
<li>CountedCompleter<T> ：在任务完成执行后会触发执行一个自定义的钩子函数</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-Future&amp;CompletableFuture&amp;Disruptor实战</title>
    <url>/2022/04/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Future&amp;CompletableFuture&amp;Disruptor%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>Future&amp;CompletableFuture&amp;Disruptor实战</p>
<span id="more"></span>

<p>为什么要有Callable？<br>直接继承Thread或者实现Runnable接口都可以创建线程，但是这两种方法都有一个问题：没有返回值，也就是不能获取执行完的结果。因此java1.5就提供了Callable接口来弥补这缺陷，而Future和FutureTask就可以和Callable接口配合起来使用。</p>
<p>Runnable的缺陷：<br>不能返回一个返回值<br>不能抛出checked Exception</p>
<p>Callable和Runnable的区别？<br>callable有返回值，可以抛出异常，并且还专门有一个Future类来与它配合使用，通过Future可以了解任务执行情况，或者取消任务的执行，还可获取任务执行的结果，这些功能都是Runnable做不到的，Callable的功能要比Runnable强大。</p>
<p>Future的使用<br>Future可以对通过Runnable或者Callable产生的任务对其执行情况进行取消、查看是否执行完毕、获取执行返回结果，可以通过get方法获取执行结果，但是该方法会导致阻塞，直到任务有返回结果。<br>Future.png</p>
<p>cancel方法是取消任务的执行。通过参数来指定是否立即中断任务执行，或者等待任务结束<br>isCancelled方法判断任务是否已取消，如果在任务正常完成前将任务取消，则返回true<br>isDone方法任务判断任务是否已完成。如果任务正常终止、异常或取消，都将返回true。<br>get() throws InterruptedException, ExecutionException方法获取方法执行完的结果，类型是V，参数InterruptedException指线程被中断的异常，ExecutionException指任务执行的异常，如果任务被取消，还会抛出CancellationException异常。<br>V get(long timeout, TimeUnit unit)  throws InterruptedException, ExecutionException, TimeoutException；方法多了两个参数，timeout是设置超时时间，uint是指定时间的单位，TimeUnit是个枚举类，当计算超时，将抛出TimeoutException异常。</p>
<p>FutureTask<br>是我们Future的实现，FutureTask存放我们任务的处理结果，充当消费者和生产者之间的桥梁，FutureTask既可以被当做Runnable来执行，也可以被当做Future来获取Callable的返回结果。<br>代码例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task task = new Task();</span><br><span class="line">//构建futureTask</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);</span><br><span class="line">//作为Runnable入参</span><br><span class="line">new Thread(futureTask).start();</span><br><span class="line">System.out.println(<span class="string">&quot;futureTask获取运行结果：&quot;</span>+futureTask.get());</span><br></pre></td></tr></table></figure>


<p>Future的注意点：<br>1.如果我们for循环获取Future结果时容易被block，然后get方法获取我们的结果是应该加个timeout限制。<br>2.Future的执行过程不可逆，一旦执行完成了任务，它的生命周期状态就永久停在了“已完成”的状态，不能重新开始。</p>
<p>Future的缺点<br>并发执行多任务：Future只能通过get()方法来获取结果，并且是阻塞的，特别是通过for循环。所以，只能等待，不过可以通过timeout参数来限制时间。<br>无法处理异常：Future接口中没有提供异常处理的方法。<br>无法对多个任务进行链式调用：当我们任务处理完时，如果我们想要做额外的事情比如发邮件这样，Future就没有提供这样的。<br>无法组合多个任务：就当我们多个任务处理完，如果我们需要他们全部执行完后执行其他动作，在Future中就不行。</p>
<p>CompletionService<br>为什么有了CompletionService接口？Callable+Future可以实现多个task并行执行，但是获取任务结果不是并行获取的，当前面的任务执行慢结果还没返回，就会导致后面的task阻塞，前面的执行完有了结果后面的task才会执行返回结果。而CompletionService就能一边生成任务，一边获得结果，不会有冲突或阻塞导致后面的task等待，这样分开的话，任务与任务之间没有阻塞，互不影响，任务执行不会再按照顺序获得结果。<br>CompletionService.png</p>
<p>CompletionService内部的实现<br>内部通过阻塞队列+FutureTask，任务先完成可先获取到结果，按照完成先后顺序排序，内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，通过调用它的take方法或poll方法可以获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果。</p>
<p>使用场景：<br>1.批量提交异步任务<br>2.通过入阻塞队列，可以实现结果处理的有序性，能有效避免无效等待<br>3.可以创建线程池，能分开创建，互不影响，适用于一些耗时的任务。</p>
<p>CompletableFuture<br>是Future接口的扩展和增强，在它的原有基础上进行了丰富地扩展，完美地弥补了Future上述的种种问题。更为重要的是，<br>CompletableFuture实现了对任务的编排能力。当我们并行执行的任务有串联，聚合关系时单用Fueture很麻烦，这就需要用到CompletableFuture。</p>
<p>CompletableFuture继承了implements Future<T>, CompletionStage<T>，其中CompletionStage接口是当我们任务执行到某个阶段，可向后异步执行其他操作。</p>
<p>依赖（串联）原理：<br>是通过thenApply()把前面异步任务的结果，交给后面的方法，thenCompose()方法用来连接两个有依赖关系的任务，结果由第二个（放在后面的）任务返回。</p>
<p>聚合原理：<br>1.通过thenCombine方法合并两个任务，有返回值的聚合。<br>2.两个任务处理完，将返回值交给thenAccepetBoth处理，无返回值。<br>3.两个任务都执行完后，通过runAfterBoth执行下一步</p>
<p>CompletableFuture创建异步任务：<br>由下面四个静态方法实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取结果：<br>通过join()和get()方法都是用来获取CompletableFuture异步之后的返回值。join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者抛出。get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）</p>
<p>我们还可以对结果处理<br>CompletableFuture返回结果或者抛出异常我们还可以操作，有如下几个重要方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</span><br><span class="line">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</span><br><span class="line">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</span><br><span class="line">public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-并发锁机制之深入理解synchronized</title>
    <url>/2022/03/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/</url>
    <content><![CDATA[<p>synchronized基础篇</p>
<span id="more"></span>
<p>Java共享内存模型带来的线程安全问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SyncDemo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做</span><br><span class="line">     * 5000 次，结果是 0 吗？</span><br><span class="line">     */</span><br><span class="line">    private static int counter = 0;</span><br><span class="line">        public static void <span class="function"><span class="title">increment</span></span>() &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void <span class="function"><span class="title">decrement</span></span>() &#123;</span><br><span class="line">        counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">            increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">            decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">         t1.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t1.join();</span><br><span class="line">         t2.join();</span><br><span class="line">         //思考： counter=？</span><br><span class="line">         log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;结果是：&quot;</span>+counter);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">//    分析结果：09:47:11.372 [main] INFO com.example.test.SyncDemo - 结果是：-3002</span><br><span class="line">//    以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。</span><br><span class="line">//    我们可以查看 i++和 i--（i 为静态变量）的 JVM 字节码指令 （ 可以在idea中安装一个jclasslib 插件)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SyncDemo.png</p>
<p>i++的JVM 字节码指令<br>1 getstatic i // 获取静态变量i的值<br>2 iconst_1 // 将int常量1压入操作数栈<br>3 iadd // 自增<br>4 putstatic i // 将修改后的值存入静态变量i<br>i–的JVM 字节码指令<br>1 getstatic i // 获取静态变量i的值<br>2 iconst_1 // 将int常量1压入操作数栈<br>3 isub // 自减<br>4 putstatic i // 将修改后的值存入静态变量i</p>
<p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题,但多线程下这 8 行代码可能交错运行,首先我们的线程2先执行（后进先出），它会去拿共享变量做减操作，假设值是5，这时候有可能出现上下文切换等操作，会让线程1执行去拿共享变量，而i–过程中4个操作不是原子的，可以被中断，那线程1执行就会拿到共享变5加1，变为6去回写，然而线程2做的操作会继续执行5-1结果是4，然后回写就会覆盖之前的6，这就有问题了，因为按理加一次减一次结果应该是还是5。</p>
<p>临界区（ Critical Section）<br>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区，其共享资源为临界资源<br>一个程序运行多个线程本身是没有问题的,问题出在多个线程访问共享资源<br>多个线程读共享资源其实也没有问题,在多个线程对共享资源读写操作时(都是读没问题，有读还有写一起)发生指令交错，就会出现问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private static int counter = 0;//临界资源</span><br><span class="line">public static void <span class="function"><span class="title">increment</span></span>() &#123;//临界区</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">public static void <span class="function"><span class="title">decrement</span></span>() &#123;//临界区</span><br><span class="line">counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>竞态条件（ Race Condition ）<br>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量<br>注意：虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的，互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码。同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
<p>synchronized的使用<br>synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内置锁，也叫作监视器锁。</p>
<p>synchronized加锁方式.png</p>
<p>解决之前的互斥问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//方法一</span><br><span class="line">public synchronized static void <span class="function"><span class="title">increment</span></span>() &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized static void <span class="function"><span class="title">decrement</span></span>() &#123;</span><br><span class="line">counter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">private static String lock = <span class="string">&quot;&quot;</span>;</span><br><span class="line">public static void <span class="function"><span class="title">increment</span></span>() &#123;</span><br><span class="line">synchronized (lock)&#123;</span><br><span class="line"> counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void <span class="function"><span class="title">decrement</span></span>() &#123;</span><br><span class="line">synchronized (lock)&#123;</span><br><span class="line"> counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized 实际是用对象锁保证了临界区内代码的原子性。还是之前的例子，首先我们的线程2去获取锁对象，获取到后就会执行代码块，同样执行到i–操作，然后我们的线程1这时候也开始执行了，会去先获取锁，发现锁对象没有被释放，因为线程2还没执行完，线程1就会被阻塞。当线程2执行完，就会释放锁，然后唤醒阻塞的线程1，线程1再去尝试获取锁，获取成功就会执行代码块。</p>
<p>synchronized底层原理<br>synchronized是JVM内置锁，基于Monitor机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、自适应自旋（Adaptive Spinning）等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。<br>同步方法是通过方法中的access_flags中设置ACC_SYNCHRONIZED标志来实现；同步代码块是通过monitorenter和monitorexit来实现。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。<br>同步方法：<br>synchronized字节码指令序列.png<br>同步代码块：<br>synchronized同步代码块字节码指令.png</p>
<p>Monitor（管程/监视器）<br>Monitor，直译为“监视器”，而操作系统领域一般翻译为“管程”。管程是指管理共享变量以及对共享变量操作的过程，让它们支持并发。在Java 1.5之前，Java语言提供的唯一并发语言就是管程，Java 1.5之后提供的SDK并发包也是以管程为基础的。除了Java之外，C/C++、C#等高级语言也都是支持管程的。synchronized关键字和wait()、notify()、notifyAll()这三个方法是Java中实现管程技术的组成部分。</p>
<p>MESA模型<br>在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模型。现在正在广泛使用的是MESA模型。下面我们便介绍MESA模型<br>mesa模型.png</p>
<p>管程中引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。条件变量和等待队列的作用是解决线程之间的同步问题。</p>
<p>对于MESA管程来说，有一个编程范式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line"><span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒的时间和获取到锁继续执行的时间是不一致的，被唤醒的线程再次执行时可能条件又不满足了，所以循环检验条件。MESA模型的wait()方法还有一个超时参数，为了避免线程进入等待队列永久阻塞。<br>满足以下三个条件时，可以使用notify()，其余情况尽量使用notifyAll()：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
<p>Java语言的内置管程synchronized<br>Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量<br>Java语言的内置管程synchronized.png</p>
<p>Monitor机制在Java中的实现<br>java.lang.Object 类定义了 wait()，notify()，notifyAll() 方法，这些方法的具体实现，依赖于 ObjectMonitor 实现，这是 JVM 内部基于 C++ 实现的一套机制。<br>ObjectMonitor其主要数据结构如下（hotspot源码ObjectMonitor.hpp）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ObjectMonitor</span></span>() &#123;</span><br><span class="line">_header = NULL; //对象头 markOop</span><br><span class="line">_count = 0;</span><br><span class="line">_waiters = 0,</span><br><span class="line">_recursions = 0; // 锁的重入次数</span><br><span class="line">_object = NULL; //存储锁对象</span><br><span class="line">_owner = NULL; // 标识拥有该monitor的线程（当前获取锁的线程）</span><br><span class="line">_WaitSet = NULL; // 等待线程（调用<span class="built_in">wait</span>）组成的双向循环链表，_WaitSet是第一个节点</span><br><span class="line">_WaitSetLock = 0 ;</span><br><span class="line">_Responsible = NULL ;</span><br><span class="line">_succ = NULL ;</span><br><span class="line">_cxq = NULL ; //多线程竞争锁会先存到这个单向链表中 （FILO栈结构）</span><br><span class="line">FreeNext = NULL ;</span><br><span class="line">_EntryList = NULL ; //存放在进入或重新进入时被阻塞(blocked)的线程 (也是存竞争锁失</span><br><span class="line">败的线程)</span><br><span class="line">_SpinFreq = 0 ;</span><br><span class="line">_SpinClock = 0 ;</span><br><span class="line">OwnerIsThread = 0 ;</span><br><span class="line">_previous_owner_tid = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObjectMonitor.png<br>在获取锁时，是将当前线程插入到cxq的头部，而释放锁时，默认策略（QMode=0）是：如果EntryList为空，则将cxq中的元素按原有顺序插入到EntryList，并唤醒第一个线程，也就是当EntryList为空时，是后来的线程先获取锁。_EntryList不为空，直接从_EntryList中唤醒线程。</p>
<p>对象的内存布局(一个对象占多数字节)<br>Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。<br>实例数据：存放类的属性数据信息，包括父类的属性信息；<br>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐</p>
<p>对象的内存布局.png</p>
<p>对象头详解<br>HotSpot虚拟机的对象头包括：<br>Mark Word<br>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。<br>Klass Pointer<br>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 32位4字节，64位开启指针压缩或最大堆内存&lt;32g时4字节，否则8字节。jdk1.8默认开启指针压缩后为4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。<br>数组长度（只有数组对象有）<br>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度，占4字节。<br>对象头详解.png</p>
<p>使用JOL工具查看内存布局<br>java对象的内部布局工具JOL(JAVA OBJECT LAYOUT)，使用此工具可以查看new出来的一个java对象的内部布局,以及一个普通的java对象占用多少字节。引入maven依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jol‐core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看对象内部信息</span><br><span class="line">System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br></pre></td></tr></table></figure>

<p>Mark Word是如何记录锁状态的<br>Hotspot通过markOop类型实现Mark Word，具体实现位于markOop.hpp文件中。由于对象需要存储的运行时数据很多，考虑到虚拟机的内存使用，markOop被设计成一个非固定的数据结构，以便在极小的空间存储尽量多的数据，根据对象的状态复用自己的存储空间。<br>简单点理解就是：MarkWord 结构搞得这么复杂，是因为需要节省内存，让同一个内存区域在不同阶段有不同的用处。</p>
<p>Mark Word的结构</p>
<p>hash： 保存对象的哈希码。运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。<br>age： 保存对象的分代年龄。表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。<br>biased_lock： 偏向锁标识位。由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。<br>lock： 锁状态标识位。区分锁状态，比如11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。<br>JavaThread*： 保存持有偏向锁的线程ID。偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。这个线程ID并不是JVM分配的线程ID号，和Java Thread中的ID是两个概念。<br>epoch： 保存偏向时间戳。偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。<br>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争时，JVM使用原子操作而不是OS互斥，这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的Mark Word中设置指向锁记录的指针。<br>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针</p>
<p>JVM下的对象结构.png</p>
<p>Mark Word中锁标记枚举</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum &#123; locked_value = 0, //00 轻量级锁</span><br><span class="line">unlocked_value = 1, //001 无锁</span><br><span class="line">monitor_value = 2, //10 监视器锁，也叫膨胀锁，也叫重量级锁</span><br><span class="line">marked_value = 3, //11 GC标记</span><br><span class="line">biased_lock_pattern = 5 //101 偏向锁</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>偏向锁撤销之调用对象HashCode<br>调用锁对象的obj.hashCode()或System.identityHashCode(obj)方法会导致该对象的偏向锁被撤销。因为对于一个对象，其HashCode只会生成一次并保存，偏向锁是没有地方保存hashcode的。</p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode<br>当对象处于可偏向（也就是线程ID为0）和已偏向的状态下，调用HashCode计算将会使对象再也无法偏向：</li>
<li>当对象可偏向时，MarkWord将变成未锁定状态，并只能升级成轻量锁；</li>
<li>当对象正处于偏向锁时，调用HashCode将使偏向锁强制升级成重量锁。</li>
</ul>
<p>轻量级锁<br>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁膨胀为重量级锁。<br>锁对象状态转换.png</p>
<p>synchronized锁优化<br>偏向锁批量重偏向&amp;批量撤销<br>从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p>以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。<br>每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。<br>当达到重偏向阈值（默认20）后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<p>应用场景<br>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>JVM的默认参数值<br>设置JVM参数-XX:+PrintFlagsFinal，在项目启动时即可输出JVM的默认参数值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">intx BiasedLockingBulkRebiasThreshold = 20 //默认偏向锁批量重偏向阈值</span><br><span class="line">intx BiasedLockingBulkRevokeThreshold = 40 //默认偏向锁批量撤销阈值</span><br></pre></td></tr></table></figure>

<p>我们可以通过-XX:BiasedLockingBulkRebiasThreshold 和 -XX:BiasedLockingBulkRevokeThreshold 来手动设置阈值<br>测试：批量重偏向<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了，于是会在给这些对象加锁时重新偏向至加锁线程，重偏向会重置对象 的 Thread ID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class BiasedLockingTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws  InterruptedException &#123;</span><br><span class="line">        //延时产生可偏向对象</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        // 创建一个list，来存放锁对象</span><br><span class="line">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 线程1</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                // 新建锁对象</span><br><span class="line">                Object lock = new Object();</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    list.add(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                //为了防止JVM线程复用，在创建完对象后，保持线程thead1状态为存活</span><br><span class="line">                Thread.sleep(100000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thead1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        //睡眠3s钟保证线程thead1创建对象完成</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        log.debug(<span class="string">&quot;打印thead1，list中第20个对象的对象头：&quot;</span>);</span><br><span class="line">        log.debug((ClassLayout.parseInstance(list.get(19)).toPrintable()));</span><br><span class="line"></span><br><span class="line">        // 线程2</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 40; i++) &#123;</span><br><span class="line">                Object obj = list.get(i);</span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=15&amp;&amp;i&lt;=21||i&gt;=38)&#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;thread2-第&quot;</span> + (i + 1) + <span class="string">&quot;次加锁执行中\t&quot;</span>+</span><br><span class="line">                                ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==17||i==19)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;thread2-第&quot;</span> + (i + 1) + <span class="string">&quot;次释放锁\t&quot;</span>+</span><br><span class="line">                            ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thead2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                Object lock =list.get(i);</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=17&amp;&amp;i&lt;=21||i&gt;=35&amp;&amp;i&lt;=41)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;thread3-第&quot;</span> + (i + 1) + <span class="string">&quot;次准备加锁\t&quot;</span>+</span><br><span class="line">                            ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (lock)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=17&amp;&amp;i&lt;=21||i&gt;=35&amp;&amp;i&lt;=41)&#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;thread3-第&quot;</span> + (i + 1) + <span class="string">&quot;次加锁执行中\t&quot;</span>+</span><br><span class="line">                                ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        log.debug(<span class="string">&quot;查看新创建的对象&quot;</span>);</span><br><span class="line">        log.debug((ClassLayout.parseInstance(new Object()).toPrintable()));</span><br><span class="line">        LockSupport.park();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BiasedLockingTest.png<br>thread1: 创建50个偏向线程thread1的偏向锁,1-18 偏向锁撤销，升级为轻量级锁 （thread1释放锁之后为偏向锁状态）,19-40 偏向锁撤销达到阈值（20），执行了批量重偏向,测试结果在第19次开始批量重偏向。</p>
<p>测试：批量撤销</p>
<p>当撤销偏向锁阈值超过 40 次后，jvm 会认为不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。<br>注意：时间-XX:BiasedLockingDecayTime=25000ms范围内没有达到40次，撤销次数清为0，重新计时。</p>
<p>还是执行之前的代码我们看执行40次后thread3<br>BiasedLockingTestTwo.png<br>thread3：<br>1-18 从无锁状态直接获取轻量级锁 （thread2释放锁之后变为无锁状态）<br>19-40 偏向锁撤销，升级为轻量级锁 （thread2释放锁之后为偏向锁状态）<br>BiasedLockingTestTwo2.png<br>41-50 达到偏向锁撤销的阈值40，批量撤销偏向锁，升级为轻量级锁 （thread1释放锁之后为偏向锁状态）</p>
<p>新创建的对象： 无锁状态<br>无锁状态.png</p>
<p>总结</p>
<ol>
<li>批量重偏向和批量撤销是针对类的优化，和对象无关。</li>
<li>偏向锁重偏向一次之后不可再次重偏向。</li>
<li>当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利</li>
</ol>
<p>自旋优化<br>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p>注意：自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调用，存在用户态和内核态切换，这才是重量级锁最大的开销）</p>
<p>锁粗化<br>假设一系列的连续操作都会对同一个对象反复加锁及解锁，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringBuffer buffer = new StringBuffer();</span><br><span class="line">/**</span><br><span class="line">* 锁粗化</span><br><span class="line">*/</span><br><span class="line">public void <span class="function"><span class="title">append</span></span>()&#123;</span><br><span class="line">buffer.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot; bbb&quot;</span>).append(<span class="string">&quot; ccc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码每次调用 buffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<p>锁消除<br>锁消除即删除不必要的加锁操作。锁消除是Java虚拟机在JIT编译期间，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class LockEliminationTest &#123;</span><br><span class="line">    StringBuffer buffer = new StringBuffer();</span><br><span class="line">    /**</span><br><span class="line">     * 锁粗化</span><br><span class="line">     */</span><br><span class="line">    public void <span class="function"><span class="title">append</span></span>()&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot; bbb&quot;</span>).append(<span class="string">&quot; ccc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 锁消除</span><br><span class="line">     * -XX:+EliminateLocks 开启锁消除(jdk8默认开启）</span><br><span class="line">     * -XX:-EliminateLocks 关闭锁消除</span><br><span class="line">     * @param str1</span><br><span class="line">     * @param str2</span><br><span class="line">     */</span><br><span class="line">    public void append(String str1, String str2) &#123;</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        LockEliminationTest demo = new LockEliminationTest();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">            demo.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer的append是个同步方法，但是append方法中的 StringBuffer 属于一个局部变量，不可能从该方法中逃逸出去，因此其实这过程是线程安全的，可以将锁消除。<br>测试结果： 关闭锁消除执行时间4058 ms 开启锁消除执行时间：2131 ms</p>
<p>总结还在整理，记录一下算法题的思路<br>1.爬楼梯问题<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>我的思路：首先想到的解题方案是用动态规划<br>思路：首先想一下假如我们最后到达了n阶，那么前面一步是不是就是n-1或者是n-2，那么我们走n阶楼梯的方法总数，就有两种可能，前一步是n-1的种数和n-2的种数，这两者的和就是走n阶楼梯的所有可能了。<br>f(n)的可能=f(n-1)+f(n-2)，也就是斐波那契数列<br>代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static int climbStairs(int n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=2)&#123;</span><br><span class="line">            <span class="built_in">return</span> n;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int array[] = new int[n];</span><br><span class="line">            array[0] = 1;</span><br><span class="line">            array[1] = 2;</span><br><span class="line">            <span class="keyword">for</span> (int i = 2; i &lt; n; i++) &#123;</span><br><span class="line">                array[i] = array[i - 1] + array[i - 2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> array[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个的时间复杂度是O（n），空间复杂度是O（n）。<br>我们试着再优化一下，在方法一中，array[i] 的状态永远依赖于 array[i-1] 和 array[i-2]，我们可以使用滚动数组的思想来把 array数组优化掉。滚动数组思想表示在一个数组中(不限维度)，某一个下标为 i的元素总是依赖于这个数组前面的某些元素，当求出这个下标为 i的元素后，前面的某些元素就可以丢弃不要了，这时就可以优化数组空间，减少内存的使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static int climbStairs(int n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=2)&#123;</span><br><span class="line">        <span class="built_in">return</span> n;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        int array[] = new int[2];</span><br><span class="line">        array[0] = 1;</span><br><span class="line">        array[1] = 2;</span><br><span class="line">        <span class="keyword">for</span> (int i = 2; i &lt; n; i++) &#123;</span><br><span class="line">//                array[i] = array[i - 1] + array[i - 2];</span><br><span class="line">            int last = array[1];</span><br><span class="line">            array[1] = array[1] + array[0];</span><br><span class="line">            array[0] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> array[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>思路：同样用动态数组的思路来解决，两个字符串，word1和word2，分别对应两个数组word1[], word2[],<br>当word1[i−1] 与 word2[j - 1]word2[j−1]相同的时候，<br>最优次数dp[i][j]=dp[i−1][j−1];</p>
<p>当word1[i - 1]与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>添加word1[i - 1]，最少操作次数为dp[i - 1][j] + 1<br>添加word2[i - 1]，最少操作次数为dp[i][j - 1]) + 1<br>更新word1[i - 1]或者word2[i - 1]使其相等，操作的最少次数为dp[i - 1][j - 1] + 1</p>
<p>所以当word1[i - 1]与 word2[j - 1]不相同的时候，<br>递推公式：dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i - 1][j], dp[i][j - 1]) + 1);</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        char[] ch1 = word1.toCharArray(), ch2 = word2.toCharArray();</span><br><span class="line">        int len1 = word1.length(), len2 = word2.length();</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        //初始化dp</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= len1; i++)&#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= len2; i++)&#123;</span><br><span class="line">            dp[0][i] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        //推导公式</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = 1; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch1[i - 1] == ch2[j - 1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-Java并发设计模式</title>
    <url>/2022/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Java%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Immutability模式</p>
<span id="more"></span>

<p>将一个类所有的属性都设置成final的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了。更严格的做法是这个类本身也是final的，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性,所以推荐在实际工作中，使用这种更严格的做法。<br>可以利用享元模式避免创建重复对象，Long、Integer、Short、Byte等这些基本数据类型的包装类都用到了享元模式这也是基本上所有的基础类型的包装类都不适合做锁的原因：它们内部用到了享元模式，这会导致看上去私有的锁，其实是共有的。在Java语言中，final修饰的属性一旦被赋值，就不可以再修改，但是如果属性的类型是普通对象，那么这个普通对象的属性是可以被修改的。所以，在使用Immutability模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。</p>
<p>Copy-On-Write模式</p>
<p>CopyOnWrite机制<br>核心思想：读写分离，空间换时间，避免为保证并发安全导致的激烈的锁竞争。<br>1、CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率；<br>2、CopyOnWrite是最终一致性，在写的过程中，原有的读的数据是不会发生更新的，只有新的读才能读到最新数据；<br>3、如何使其他线程能够及时读到新的数据，需要使用volatile变量；<br>4、写的时候不能并发写，需要对写操作进行加锁；<br>CopyOnWrite.png</p>
<p>Copy-on-Write 才是最简单的并发解决方案，很多人都在无意中把它忽视了。它是如此简单，以至于 Java 中的基本数据类型 String、Integer、Long 等都是基于 Copy-on-Write 方案实现的。<br>Copy-on-Write 缺点就是消耗内存，每次修改都需要复制一个新的对象出来，好在随着自<br>动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实<br>际工作中，如果写操作非常少（读多写少的场景），可以尝试使用 Copy-on-Write。</p>
<p>线程本地存储模式<br>在Java标准类库中，ThreadLocal 类实现了该模式，线程本地存储模式本质上是一种避免共享的方案，由于没有共享，所以自然也就没有并发问题。如果你需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。</p>
<p>GuardedSuspension：等待唤醒机制的规范实现<br>概念：<br>”多线程版本的if“，需要等待，而且必须要等到条件为真<br>场景：<br>多用来异步转同步<br>案例：<br>用户通过浏览器发过来一个请求，会被转换成一个异步消息发送给MQ，等MQ返回结果后，再将这个结果返回至浏览器。<br>给MQ发送消息的线程是处理Web请求的线程T1，但消费MQ结果的线程并不是线程T1，那线程T1如何等待MQ的返回结果呢？<br>GuardedSuspension.png</p>
<p>Balking模式<br>同为”多线程版本的if“，但不是所有场景都需要一直等待到条件成立，所以出现此模式，可以快速放弃。<br>案例：<br>各种编辑器提供的自动保存功能；<br>自动保存功能的实现逻辑一般都是隔一定时间自动执行存盘操作；<br>存盘操作的前提是文件做过修改，如果文件没有执行过修改操作，就需要快速放弃存盘操作<br>这里可以使用synchronized将读写共享变量changed的方法autoSave()和edit()都加互斥锁。这样做虽然简单，但是性能很差，原因是锁的范围太大了。可以将锁的范围缩小，只在读写共享变量changed的地方加锁。</p>
<p>常见的应用场景：<br>1.sychronized轻量级锁膨胀逻辑， 只需要一个线程膨胀获取monitor对象<br>2.DCL单例实现<br>3.服务组件的初始化</p>
<p>多线程分工模式<br>Thread-Per-Message 模式、Worker Thread 模式和生产者 - 消费者模式属于多线程分工模式。<br>Thread-Per-Message 模式需要注意线程的创建，销毁以及是否会导致OOM。<br>Worker Thread 模式需要注意死锁问题，提交的任务之间不要有依赖性。<br>生产者 - 消费者模式可以直接使用线程池来实现</p>
<p>Thread-Per-Message 模式——最简单实用的分工方法<br>Thread-Per-Message 模式就是为每个任务分配一个独立的线程，这是一种最简单的分工方法。</p>
<p>使用场景：<br>对于一些并发度没那么高的异步场景，例如定时任务，采用 Thread-Per-Message 模式是完全没有问题的。</p>
<p>Worker Thread模式——如何避免重复创建线程<br>可以有效避免线程的频繁创建、销毁以及 OOM 问题，用阻塞队列做任务池，然后创建固定数量的线程消费阻塞队列中的任务，类似车间工作。<br>Worker Thread.png<br>可以使用线程池来实现此方案，提交到相同线程池中的任务一定要是相互独立的，否则就一定要慎重，避免死锁</p>
<p>两阶段终止模式：优雅地终止线程<br>在一个线程T1中，终止线程T2，终止时不是立马就结束它，而是给它一个做后事的机会，将终止过程分成两个阶段，其中第一个阶段主要是线程T1向线程T2发送终止指令，而第二阶段则是线程T2响应终止指令。</p>
<p>使用场景：<br>用两阶段终止模式终止监控操作，监控系统发送采集指令给被监控系统的监控代理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统：<br>监控系统.png</p>
<p>shutdown()方法是一种很保守的关闭线程池的方法。线程池执行shutdown()后，就会拒绝接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后才最终关闭线程池。<br>shutdownNow()则会拒绝接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行的机会，不过这些被剥夺执行机会的任务会作为shutdownNow()方法的返回值返回。因为shutdownNow()方法会中断正在执行的线程，所以提交到线程池的任务，如果需要优雅地结束，就需要正确地处理线程中断。<br>线程池的shutdown()和shutdownNow()方法实质上使用的也是两阶段终止模式，只是终止指令的范围不同而已：前者只影响阻塞队列接收任务，后者范围扩大到线程池中所有的任务。</p>
<p>生产者-消费者模式：用流水线思想提高效率<br>Worker Thread模式类比的是工厂里车间工人的工作模式<br>但其实在现实世界，工厂里还有一种流水线的工作模式，类比到编程领域，就是生产者-消费者模式</p>
<p>好处：平衡生产者和消费者的速度差异,支持异步处理。</p>
<p>使用场景：<br>1.批量执行场景<br>如要在数据库里INSERT 1000条数据，有两种方案：<br>一种方案是用1000个线程并发执行，每个线程INSERT一条数据；第二种方案是用1个线程，执行一个批量的SQL，一次性把1000条数据INSERT进去。这两种方案，显然是第二种方案效率更高</p>
<p>2.支持分阶段提交<br>写文件如果同步刷盘性能会很慢，所以对于不是很重要的数据，往往采用异步刷盘的方式：<br>写入日志的方法可以通过创建日志任务并添加到阻塞队列中来实现，调用此方法的线程是生产者，而真正将日志写入文件的是消费者线程</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-深入理解AQS之CyclicBarrier&amp;ReentrantReadWriteLock</title>
    <url>/2022/03/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BCyclicBarrier&amp;ReentrantReadWriteLock/</url>
    <content><![CDATA[<p>读写锁介绍</p>
<span id="more"></span>

<p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁（读多写少）。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源（读读可以并发）；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写操作了（读写，写读，写写互斥）。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p>
<p>针对这种场景，JAVA的并发包提供了读写锁ReentrantReadWriteLock，它内部，维护了一对相关的锁，一个用于只读操作，称为读锁；一个用于写入操作，称为写锁，描述如下：线程进入读锁的前提条件：<br>没有其他线程的写锁</p>
<ul>
<li>没有写请求或者有写请求，但调用线程和持有锁的线程是同一个。</li>
<li>线程进入写锁的前提条件：</li>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
<li>而读写锁有以下三个重要的特性：</li>
<li>公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>
<li>可重入：读锁和写锁都支持线程重入。以读写线程为例：读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁。</li>
<li>锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁。</li>
</ul>
<p>ReentrantReadWriteLock的使用<br>读写锁接口ReadWriteLock<br>ReadWriteLock.png<br>两个方法，分别获得读锁和写锁 Lock 对象。</p>
<p>ReentrantReadWriteLock类结构<br>ReentrantReadWriteLock是可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 Writer 线程，读锁可以由多个 Reader 线程同时持有。也就是说，写锁是独占的，读锁是共享的。<br>ReentrantReadWriteLock.png</p>
<p>使用读写锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">private Lock r = readWriteLock.readLock();</span><br><span class="line">private Lock w = readWriteLock.writeLock();</span><br><span class="line">// 读操作上读锁</span><br><span class="line">public Data get(String key) &#123;</span><br><span class="line">r.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// TODO 业务逻辑</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 写操作上写锁</span><br><span class="line">public Data put(String key, Data value) &#123;</span><br><span class="line">w.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// TODO 业务逻辑</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：持有读锁的情况下去获取写锁，会导致获取永久等待</li>
<li>重入时支持降级： 持有写锁的情况下可以去获取读锁</li>
</ul>
<p>应用场景<br>ReentrantReadWriteLock适合读多写少的场景</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ReentrantReadWriteLockDemo &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">return</span> map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">return</span> map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void <span class="function"><span class="title">clear</span></span>() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLockDemo是用非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新 HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而 只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式</p>
<p>锁降级<br>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。锁降级可以帮助我们拿到当前线程修改后的结果而不被其他线程所破坏，防止更新丢失。</p>
<p>锁降级的使用示例<br>因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ReentrantReadWriteLockDemo &#123;</span><br><span class="line">    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    private final Lock readLock = rwl.readLock();</span><br><span class="line">    private final Lock writeLock = rwl.writeLock();</span><br><span class="line">    private volatile boolean update = <span class="literal">false</span>;</span><br><span class="line">    public void <span class="function"><span class="title">processData</span></span>() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        //读操作锁住</span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            // 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            // 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                //writeLock.lock();获取到写锁基础上，把持住写锁，然后获取到读锁</span><br><span class="line">                <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                    // TODO 准备数据的流程（略）</span><br><span class="line">                    update = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //完成之后释放写锁</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 锁降级完成，写锁降级为读锁</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            //TODO 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。<br>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<p>ReentrantReadWriteLock结构.png<br>红色线内置类，蓝色线父子类，绿色线实现接口。</p>
<p>实现一把锁锁该如何设计？</p>
<p>1.CAS加上自旋，自旋到一定次数就阻塞，操作是修改state状态0-》1<br>2.通过管程，Synchronized<br>3.借鉴AQS的实现，CAS加上同步队列，操作是修改state状态0-》1，CAS获取锁成功就操作，失败就阻塞到同步队列，释放锁1-》0<br>如果锁是独占锁，就调用tryAcquired方法，共享锁就调用tryAcquiredShared</p>
<p>设计分布式锁？<br>是否跨jvm进程？分布式情景下不同的节点是不同的jvm进程，java实现的AQS不能跨jvm进程，但是可以借鉴，实现进程之前的通信，java有JMM，线程与线程有个共享的区域，我们可以有个进程的共享区域，那可以redis，zk，mysql等，把状态交给redis去管理，进程和进程之间都可以操作这个共享的区域。redis里面可以用hash的结构，具体实现还是比较麻烦，可以借鉴工具。</p>
<p>读写状态的设计<br>设计的精髓：用一个变量如何维护多种状态在 ReentrantLock 中，使用 Sync ( 实际是 AQS )的 int 类型的 state 来表示同步状态，表示锁被一个线程重复获取的次数。但是，读写锁 ReentrantReadWriteLock 内部维护着一对读写锁，如果要用一个变量维护多种状态，需要采用“按位切割使用”的方式来维护这个变量，将其切分为两部分：高16为表示读，低16为表示写。分割之后，读写锁是如何迅速确定读锁和写锁的状态呢？通过位运算。假如当前同步状态为S，那么：</p>
<ul>
<li>写状态，等于 S &amp; 0x0000FFFF（将高 16 位全部抹去）。 当写状态加1，等于S+1.</li>
<li>读状态，等于 S &gt;&gt;&gt; 16 (无符号补 0 右移 16 位)。当读状态加1，等于S+（1&lt;&lt;16）,也就是S+0x00010000<br>根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</li>
</ul>
<p>HoldCounter 计数器<br>读锁的内在机制其实就是一个共享锁。一次共享锁的操作就相当于对HoldCounter 计数器的操作。获取共享锁，则该计数器 + 1，释放共享锁，该计数器 - 1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。</p>
<p>通过 ThreadLocalHoldCounter 类，HoldCounter 与线程进行绑定。HoldCounter 是绑定线程的一个计数器，而 ThreadLocalHoldCounter 则是线程绑定的 ThreadLocal。HoldCounter是用来记录读锁重入数的对象<br>ThreadLocalHoldCounter是ThreadLocal变量，用来存放不是第一个获取读锁的线程的其他线程的读锁重入数对象</p>
<p>写锁的获取<br>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。写锁的获取是通过重写AQS中的tryAcquire方法实现的。</p>
<ul>
<li>读写互斥</li>
<li>写写互斥</li>
<li>写锁支持同一个线程重入</li>
<li>writerShouldBlock写锁是否阻塞实现取决公平与非公平的策略（FairSync和NonfairSync）<br>ReentrantReadWriteLock写锁获取.png</li>
</ul>
<p>写锁的释放<br>写锁释放通过重写AQS的tryRelease方法实现<br>ReentrantReadWriteLock写锁释放.png</p>
<p>读锁的获取<br>实现共享式同步组件的同步语义需要通过重写AQS的tryAcquireShared方法和tryReleaseShared方法。</p>
<ul>
<li>读锁共享，读读不互斥</li>
<li>读锁可重入，每个获取读锁的线程都会记录对应的重入数</li>
<li>读写互斥，锁降级场景除外</li>
<li>支持锁降级，持有写锁的线程，可以获取读锁，但是后续要记得把读锁和写锁读释放</li>
<li>readerShouldBlock读锁是否阻塞实现取决公平与非公平的策略（FairSync和NonfairSync）<br>ReentrantReadWriteLock读锁获取.png</li>
</ul>
<p>读锁的释放<br>获取到读锁，执行完临界区后，要记得释放读锁（如果重入多次要释放对应的次数），不然会阻塞其他线程的写操作。<br>读锁释放的实现主要通过方法tryReleaseShared。<br>ReentrantReadWriteLock读锁.png</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-深入理解AQS之Semaphorer&amp;CountDownLatch&amp;Cyclic详解</title>
    <url>/2022/03/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer&amp;CountDownLatch&amp;Cyclic%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Semaphore介绍</p>
<span id="more"></span>
<p>Semaphore，俗称信号量，它是操作系统中PV操作的原语在java的实现，它也是基于AbstractQueuedSynchronizer实现的。<br>Semaphore的功能非常强大，大小为1的信号量就类似于互斥锁，通过同时只能有一个线程获取信号量实现。大小为n（n&gt;0）的信号量可以实现限流的功能，它可以实现只能有n个线程同时获取信号量。</p>
<p>Semaphore 常用方法<br>Semaphore.png</p>
<p>permits 表示许可证的数量（资源数）<br>fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程<br>常用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public void acquire() throws InterruptedException</span><br><span class="line">public boolean tryAcquire()</span><br><span class="line">public void release()</span><br><span class="line">public int availablePermits()</span><br><span class="line">public final int getQueueLength()</span><br><span class="line">public final boolean hasQueuedThreads()</span><br><span class="line">protected void reducePermits(int reduction)</span><br><span class="line">protected Collection&lt;Thread&gt; getQueuedThreads()</span><br></pre></td></tr></table></figure>

<p>acquire() 表示阻塞并获取许可<br>tryAcquire() 方法在没有许可的情况下会立即返回 false，要获取许可的线程不会阻塞<br>release() 表示释放许可<br>int availablePermits()：返回此信号量中当前可用的许可证数。<br>int getQueueLength()：返回正在等待获取许可证的线程数。<br>boolean hasQueuedThreads()：是否有线程正在等待获取许可证。<br>void reducePermit（int reduction）：减少 reduction 个许可证<br>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合</p>
<p>应用场景<br>可以用于做流量控制，特别是公用资源有限的应用场景</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SemaPhoneTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 实现一个同时只能处理5个请求的限流器</span><br><span class="line">     */</span><br><span class="line">    private static Semaphore semaphore = new Semaphore(5);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义一个线程池</span><br><span class="line">     */</span><br><span class="line">    private static ThreadPoolExecutor executor = new ThreadPoolExecutor</span><br><span class="line">            (10, 50, 60,</span><br><span class="line">                    TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(200));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 模拟执行方法</span><br><span class="line">     */</span><br><span class="line">    public static void <span class="function"><span class="title">exec</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //占用1个资源</span><br><span class="line">            semaphore.acquire(1);</span><br><span class="line">            //TODO  模拟业务执行</span><br><span class="line">            System.out.println(<span class="string">&quot;执行exec方法:&quot;</span>);</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放一个资源</span><br><span class="line">            semaphore.release(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i=0; ;i++ ) &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                // 模拟请求以10个/s的速度</span><br><span class="line">                executor.execute(() -&gt; <span class="built_in">exec</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch介绍<br>CountDownLatch（闭锁）是一个同步协助类，允许一个或多个线程等待，直到其他线程完成操作集。<br>CountDownLatch使用给定的计数值（count）初始化。await方法会阻塞直到当前的计数值（count）由于countDown方法的调用达到0，count为0之后所有等待的线程都会被释放，并且随后对await方法的调用都会立即返回。这是一个一次性现象 —— count不会被重置。如果<br>你需要一个重置count的版本，那么请考虑使用CyclicBarrier。</p>
<p>CountDownLatch的使用<br>构造器<br>CountDownLatch.png</p>
<p>常用方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 调用 await() 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行</span><br><span class="line">public void await() throws InterruptedException &#123; &#125;;</span><br><span class="line">// 和 await() 类似，若等待 timeout 时长后，count 值还是没有变为 0，不再等待，继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;</span><br><span class="line">// 会将 count 减 1，直至为 0</span><br><span class="line">public void <span class="function"><span class="title">countDown</span></span>() &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch应用场景<br>CountDownLatch一般用作多线程倒计时计数器，强制它们等待其他一组（CountDownLatch<br>的初始化决定）任务执行完成。<br>CountDownLatch的两种使用场景：<br>场景1：让多个线程等待<br>场景2：让单个线程等待。</p>
<p>场景1 让多个线程等待：模拟并发，让并发线程一起执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //准备完毕……运动员都阻塞在这，等待号令</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    String parter = <span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】&quot;</span>;</span><br><span class="line">                    System.out.println(parter + <span class="string">&quot;开始执行……&quot;</span>);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);// 裁判准备发令</span><br><span class="line">        countDownLatch.countDown();// 发令枪：执行发令</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>场景2 让单个线程等待：多个线程(任务)完成后，进行汇总合并<br>很多时候，我们的并发任务，存在前后依赖关系；比如数据详情页需要同时调用多个接口获取数据，并发请求获取到数据后、需要进行结果合并；或者多个数据操作完成后，需要数据check；这其实都是：在多个线程(任务)完成后，进行汇总合并的场景。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(5);</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int index = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000 +</span><br><span class="line">                            ThreadLocalRandom.current().nextInt(1000));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; finish task&quot;</span> + index);</span><br><span class="line"></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 主线程在阻塞，当计数器==0，就唤醒主线程往下执行。</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程:在所有任务运行完成后，进行结果汇总&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>CountDownLatch实现原理<br>底层基于 AbstractQueuedSynchronizer 实现，CountDownLatch 构造函数中指定的count直接赋给AQS的state；每次countDown()则都是release(1)减1，最后减到0时unpark阻塞线程；这一步是由最后一个执行countdown方法的线程执行的。而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。</p>
<p>CountDownLatch与Thread.join的区别<br>CountDownLatch的作用就是允许一个或多个线程等待其他线程完成操作，看起来有点类似join() 方法，但其提供了比 join() 更加灵活的API。<br>CountDownLatch可以手动控制在n个线程里调用n次countDown()方法使计数器进行减一操作，也可以在一个线程里调用n次执行减一操作。而 join() 的实现原理是不停检查join线程是否存活，如果 join 线程存活则让当前线程永远等待。所以两者之间相对来说还是CountDownLatch使用起来较为灵活。</p>
<p>CountDownLatch与CyclicBarrier的区别<br>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p>
<ul>
<li><ol>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li>
</ol>
</li>
<li><ol start="2">
<li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li>
</ol>
</li>
<li><ol start="3">
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li>
</ol>
</li>
<li><ol start="4">
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再执行。CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</li>
</ol>
</li>
<li><ol start="5">
<li>CyclicBarrier 还可以提供一个 barrierAction，合并多线程计算结果。</li>
</ol>
</li>
<li><ol start="6">
<li>CyclicBarrier是通过ReentrantLock的”独占锁”和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现</li>
</ol>
</li>
</ul>
<p>CyclicBarrier介绍<br>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p>
<p>CyclicBarrier的使用<br>构造方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// parties表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</span><br><span class="line">public CyclicBarrier(int parties)</span><br><span class="line">// 用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景(该线程的执行时机是在到达屏障之后再执行)</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction)</span><br></pre></td></tr></table></figure>

<p>重要方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//屏障 指定数量的线程全部调用await()方法时，这些线程不再阻塞</span><br><span class="line">// BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</span><br><span class="line">public int await() throws InterruptedException, BrokenBarrierException</span><br><span class="line">public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException,TimeoutException</span><br><span class="line">//循环 通过reset()方法可以进行重置</span><br><span class="line">public void reset()</span><br></pre></td></tr></table></figure>
<p>CyclicBarrier应用场景<br>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的场景。</p>
<p>CyclicBarrier与CountDownLatch的区别(完善上面的)</p>
<ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li>
<li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li>
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再执行。CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</li>
<li>CyclicBarrier 还可以提供一个 barrierAction，合并多线程计算结果。</li>
<li>CyclicBarrier是通过ReentrantLock的”独占锁”和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-深入理解AQS之独占锁ReentrantLock源码分析</title>
    <url>/2022/03/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8B%E7%8B%AC%E5%8D%A0%E9%94%81ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>深入理解AQS之独占锁ReentrantLock源码分析<span id="more"></span><br>什么是AQS<br>java.util.concurrent包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这些行为的抽象就是基于AbstractQueuedSynchronizer（简称AQS）实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。JDK中提供的大多数的同步器如Lock, Latch, Barrier等，都是基于AQS框架来实现的</p>
<p>一般是通过一个内部类Sync继承 AQS将同步器所有调用都映射到Sync对应的方法</p>
<p>AQS具备的特性：</p>
<ul>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>允许中断</li>
</ul>
<p>AQS内部维护属性volatile int state<br>state表示资源的可用状态<br>State三种访问方式：</p>
<ul>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ul>
<p>AQS定义两种资源共享方式<br>Exclusive-独占，只有一个线程能执行，如ReentrantLock<br>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</p>
<p>AQS定义两种队列<br>同步等待队列： 主要用于维护获取锁失败时入队的线程<br>条件等待队列： 调用await()的时候会释放锁，然后线程会加入到条件队列，调用signal()唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁</p>
<p>AQS 定义了5个队列中节点状态：</p>
<ol>
<li>值为0，初始化状态，表示当前节点在sync队列中，等待着获取锁。</li>
<li>CANCELLED，值为1，表示当前的线程被取消；</li>
<li>SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</li>
<li>CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</li>
<li>PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</li>
</ol>
<p>不同的自定义同步器竞争共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>同步等待队列<br>AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列，是FIFO先进先出线程等待队列，Java中的CLH队列是原CLH队列的一个变种,线程由原自旋机制改为阻塞机制。<br>AQS 依赖CLH同步队列来完成同步状态的管理：</p>
<ul>
<li>当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</li>
<li>当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</li>
<li>通过signal或signalAll将条件队列中的节点转移到同步队列。（由条件队列转化为同步队列）</li>
</ul>
<p>CLH队列.png</p>
<p>条件等待队列<br>AQS中条件队列是使用单向列表保存的，用nextWaiter来连接:</p>
<ul>
<li>调用await方法阻塞线程；</li>
<li>当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转化到条件队列）</li>
</ul>
<p>Condition接口详解</p>
<ol>
<li>调用Condition#await方法会释放当前持有的锁，然后阻塞当前线程，同时向Condition队列尾部添加一个节点，所以调用Condition#await方法的时候必须持有锁。</li>
<li>调用Condition#signal方法会将Condition队列的首节点移动到阻塞队列尾部，然后唤醒因调用Condition#await方法而阻塞的线程(唤醒之后这个线程就可以去竞争锁了)，所以调用Condition#signal方法的时候必须持有锁，持有锁的线程唤醒被因调用<br>Condition#await方法而阻塞的线程。</li>
</ol>
<p>ReentrantLock详解<br>ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized是一种互斥锁，可以保证线程安全。相对于 synchronized， ReentrantLock具备如下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
<li>与 synchronized 一样，都支持可重入</li>
</ul>
<p>总结了几点synchronized和ReentrantLock的区别：</p>
<ul>
<li>synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；</li>
<li>synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；</li>
<li>在发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li>
<li>synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（回顾一下sychronized的唤醒策略），而ReentrantLock对于已经在等待的线程是先来的线程先获得锁</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-深入理解Java线程</title>
    <url>/2022/03/13/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>线程和进程</p>
<span id="more"></span>

<p>进程<br>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。<br>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p>
<p>进程<br>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位</p>
<p>进程与线程的区别<br>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集，进程拥有共享的资源，如内存空间等，供其内部的线程共享进程间通信较为复杂<br>同一台计算机的进程通信称为 IPC（Inter-processcommunication）不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，<br>例如 HTTP线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
<p>进程间通信的方式</p>
<ul>
<li><p>管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
</li>
<li><p>信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p>
</li>
<li><p>消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p>
</li>
<li><p>共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p>
</li>
<li><p>信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p>
</li>
<li><p>套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p>
</li>
</ul>
<p>线程的同步互斥<br>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。<br>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<p>四种线程同步互斥的控制方法<br>临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。（在一段时间内只允许一个线程访问的资源就称为临界资源）。<br>互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>信号量:为控制一个具有有限数量用户资源而设计。<br>事件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
<p>上下文切换（Context switch）<br>上下文切换是指CPU(中央处理单元)从一个进程或线程到另一个进程或线程的切换。进程是程序的一个执行实例。在Linux中，线程是轻量级进程，可以并行运行，并与父进程(即创建线程的进程)共享一个地址空间和其他资源。<br>上下文是CPU寄存器和程序计数器在任何时间点的内容。<br>寄存器是CPU内部的一小部分非常快的内存(相对于CPU外部较慢的RAM主内存)，它通过提供对常用值的快速访问来加快计算机程序的执行。<br>程序计数器是一种专门的寄存器，它指示CPU在其指令序列中的位置，并保存着正在执行的指令的地址或下一条要执行的指令的地址，这取决于具体的系统。</p>
<p>上下文切换可以更详细地描述为内核(即操作系统的核心)对CPU上的进程(包括线程)执行以下活动:</p>
<ol>
<li>暂停一个进程的处理，并将该进程的CPU状态(即上下文)存储在内存中的某个地方</li>
<li>从内存中获取下一个进程的上下文，并在CPU的寄存器中恢复它</li>
<li>返回到程序计数器指示的位置(即返回到进程被中断的代码行)以恢复进程</li>
</ol>
<p>上下文切换只能在内核模式下发生。内核模式是CPU的特权模式，其中只有内核运行，并提供对所有内存位置和所有其他系统资源的访问。其他程序(包括应用程序)最初在用户模式下运行，但它们可以通过系统调用运行部分内核代码。</p>
<p>上下文切换是多任务操作系统的一个基本特性。在多任务操作系统中，多个进程似乎同时在一个CPU上执行，彼此之间互不干扰。这种并发的错觉是通过快速连续发生的上下文切换(每秒数十次或数百次)来实现的。这些上下文切换发生的原因是进程自愿放弃它们在CPU中的时间，或者是调<br>度器在进程耗尽其CPU时间片时进行切换的结果。<br>上下文切换通常是计算密集型的。就CPU时间而言，上下文切换对系统来说是一个巨大的成本，实际上，它可能是操作系统上成本最高的操作。因此，操作系统设计中的一个主要焦点是尽可能地避免不必要的上下文切换。与其他操作系统(包括一些其他类unix系统)相比，Linux的众多优势之一是它的上下文切换和模式切换成本极低。</p>
<p>通过命令查看CPU上下文切换情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#可以看到整个操作系统每1秒CPU上下文切换的统计</span></span><br><span class="line">vmstat 1</span><br></pre></td></tr></table></figure>
<p>linux上下文切换.png</p>
<p>其中cs列就是CPU上下文切换的统计。当然，CPU上下文切换不等价于线程切换，很多操作会造<br>成CPU上下文切换：线程、进程切换,系统调用,中断</p>
<p>查看某一个线程\进程的上下文切换使用pidstat命令<br>常用的参数：<br>-u 默认参数，显示各个进程的 CPU 统计信息<br>-r 显示各个进程的内存使用情况<br>-d 显示各个进程的 IO 使用<br>-w 显示各个进程的上下文切换<br>-p PID 指定 PID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示进程5598每一秒的切换情况</span></span><br><span class="line">pidstat ‐w ‐p 5598 1</span><br></pre></td></tr></table></figure>
<p>其中cswch表示主动切换，nvcswch表示被动切换。</p>
<p>操作系统层面线程生命周期<br>操作系统层面的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态</p>
<p>线程生命周期.png</p>
<p>初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</p>
<p>可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</p>
<p>当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到CPU 的线程的状态就转换成了运行状态。</p>
<p>运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</p>
<p>线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</p>
<p>查看进程线程的方法:<br>windows</p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist 查看进程</li>
<li>taskkill 杀死进程</li>
</ul>
<p>linux</p>
<ul>
<li>ps -fe 查看所有进程</li>
<li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li>
<li>kill 杀死进程</li>
<li>top 按大写 H 切换是否显示线程</li>
<li>top -H -p <PID> 查看某个进程（PID）的所有线程</li>
</ul>
<p>Java</p>
<ul>
<li>jps 命令查看所有 Java 进程</li>
<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<p>Linux系统中线程实现方式</p>
<ul>
<li>LinuxThreads linux/glibc包在2.3.2之前只实现了LinuxThreads</li>
<li>NPTL(Native POSIX Thread Library)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以通过以下命令查看系统是使用哪种线程实现</span></span><br><span class="line">getconf GNU_LIBPTHREAD_VERSION</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Java线程的实现方式<br>方式1：使用 Thread类或继承Thread类<br>方式2：实现 Runnable 接口配合Thread<br>方式3：使用有返回值的 Callable<br>方式4：使用 lambda<br>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-JVM内存分配</title>
    <url>/2022/02/21/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h2 id="JVM内存分配"><a href="#JVM内存分配" class="headerlink" title="JVM内存分配"></a>JVM内存分配</h2><span id="more"></span>

<p>JVM内存参数设置</p>
<p><img src="/images/JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png"></p>
<p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eurek</span><br><span class="line">a‐server.jar</span><br></pre></td></tr></table></figure>

<p>关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N<br>-XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。<br>-XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发<br>full gc进行类型卸载，不仅会回收推，还会回收方法区， 同时收集器会对该值进行调整（方法区容量大小自动收缩扩容）： 如果释放（回收）了大量的空间， 就适当降低该值，比如从之前21降为15； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值，可能在之前21变为30,或40。这个跟早期jdk版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久代的初始容量。<br>Xss512K是指一个栈线程的大小，可以自己指定，-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p>
<p>元空间在JDK1.8之前叫永久代、持久代，它用的是直接内存，也就是物理内存，我们的内存条，假如我们8G的内存，4G分配给了堆栈等其他的，那么剩下的内存如果对上面两个参数不设置的话就会全部占用其剩余内存。由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="/images/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.png"></p>
<p>1.1.类加载检查<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。<br>1.2.分配内存<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。<br>这个步骤有两个问题：</p>
<ul>
<li>1.如何划分内存。</li>
<li>2.在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的<br>情况。<br>划分内存的方法：<br>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。<br>“空闲列表”（Free List）<br>如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟<br>机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，<br>并更新列表上的记录<br>解决并发问题的方法：<br>CAS（compare and swap）<br>虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过­XX:+/­UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小。<br>TLAB全称Thread Local Allocation Buffer，即线程本地分配缓存区，是一个线程专用的内存分配区域。在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用。jdk1.8默认使用的就是该种方式。<br>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间线程专属。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如需要分配内存，在自己的空间上分配，在不存在竞争的情况大大提升分配效率。<br>　　上面描述中”线程专属”、”只给当前线程使用”、”每个线程单独拥有”的描述怎么理解呢？因TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。TLAB是线程独享的，但只在“分配”这个动作上是线程独享，在读取、垃圾回收等动作上是线程共享，且在使用上也没有什么区别。</li>
</ul>
<p>1.3.初始化<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。<br>1.4.设置对象头<br>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>1.5.执行init方法<br>执行init方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p>
<p>对象大小与指针压缩<br>对象大小可以用jol­core包查看，引入依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;jol‐core&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>代码查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class JOLSample &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> ClassLayout layout = ClassLayout.parseInstance(new Object());</span><br><span class="line"> System.out.println(layout.toPrintable());</span><br><span class="line"> System.out.println();</span><br><span class="line"> ClassLayout layout1 = ClassLayout.parseInstance(new int[]&#123;&#125;);</span><br><span class="line"> System.out.println(layout1.toPrintable());</span><br><span class="line"> System.out.println();</span><br><span class="line"> ClassLayout layout2 = ClassLayout.parseInstance(new A());</span><br><span class="line"> System.out.println(layout2.toPrintable());</span><br><span class="line"> &#125;</span><br><span class="line"> // ‐XX:+UseCompressedOops 默认开启的压缩所有指针</span><br><span class="line"> // ‐XX:+UseCompressedClassPointers 默认开启的压缩对象头里的类型指针Klass Pointer</span><br><span class="line"> // Oops : Ordinary Object Pointers</span><br><span class="line"> public static class A &#123;</span><br><span class="line"> //8B mark word</span><br><span class="line"> //4B Klass Pointer 如果关闭压缩‐XX:‐UseCompressedClassPointers或‐XX:‐UseCompressedOops，则占用8B</span><br><span class="line"> int id; //4B</span><br><span class="line"> String name; //4B 如果关闭压缩‐XX:‐UseCompressedOops，则占用8B</span><br><span class="line"> byte b; //1B</span><br><span class="line"> Object o; //4B 如果关闭压缩‐XX:‐UseCompressedOops，则占用8B</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>什么是java对象的指针压缩？<br>1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩<br>2.jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针<br>3.启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­UseCompressedOops</p>
<p>为什么要进行指针压缩？<br>1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力<br>2.为了减少64位平台下内存的消耗，启用指针压缩功能<br>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)<br>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间<br>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p>
<h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h2><p>我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内<br>存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数<br>量，JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的<br>内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。<br>对象逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参<br>数传递到其他地方中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class ExtClass&#123;</span><br><span class="line">    public TestThree <span class="function"><span class="title">A</span></span>()&#123;</span><br><span class="line">        TestThree od=new TestThree();</span><br><span class="line">        od.setA(1);</span><br><span class="line">        od.setName(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span>  od;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">B</span></span>()&#123;</span><br><span class="line">        TestThree od=new TestThree();</span><br><span class="line">        od.setA(2);</span><br><span class="line">        od.setName(<span class="string">&quot;Roy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面A方法中的od对象被返回了，这个对象的作用域范围不确定，B方法中的od对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过标量替换优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。<br>标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p>
<p>总结：如果栈上分配对象就会依赖于逃逸分析和标量替换</p>
<p>对象在Eden区分配<br>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。<br>Minor GC/Young GC：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。<br>Major GC/Full GC：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。Eden与Survivor区默认8:1:1</p>
<p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活<br>的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回<br>收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所<br>以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可，<br>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变<br>化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
<p>大对象直接进入老年代：<br>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC ，设置大小后，判断对象只要超过这个大小就会进入老年代。</p>
<p>为什么要这样呢？<br>为了避免为大对象分配内存时的复制操作而降低效率。</p>
<p>长期存活的对象将进入老年代：<br>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在<br>老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。那我们就可以自己判断给一个适当的值，让它提前进入老年代，可以起到减少gc消耗的作用，给它减压。</p>
<p>对象动态年龄判断：<br>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的<br>50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，<br>例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会<br>把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年<br>龄判断机制一般是在minor gc之后触发的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之深入理解JMM&amp;并发三大特性</title>
    <url>/2022/03/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM&amp;%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>目标都是最大化CPU的使用率，不让cpu闲置着。</p>
<span id="more"></span>
<p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的,可以理解为多个应用程序一起执行。</p>
<p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。可以理解为一对一。</p>
<p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。<br>并发解决多线程之间同步，互斥，分工的问题。</p>
<h3 id="并发三大特性"><a href="#并发三大特性" class="headerlink" title="并发三大特性"></a>并发三大特性</h3><p>并发编程Bug的源头：可见性、原子性和有序性问题</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。<br>如何保证可见性：</p>
<ul>
<li>通过 volatile 关键字保证可见性。</li>
<li>通过 内存屏障保证可见性。</li>
<li>通过 synchronized 关键字保证可见性。</li>
<li>通过 Lock保证可见性。</li>
<li>通过 final 关键字保证可见性<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4>即程序执行的顺序按照代码的先后顺序执行。JVM 存在指令重排，所以存在有序性问题。<br>如何保证有序性：</li>
<li>通过 volatile 关键字保证可见性。</li>
<li>通过 内存屏障保证可见性。</li>
<li>通过 synchronized关键字保证有序性。</li>
<li>通过 Lock保证有序性。<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作（64位处理器）。不采取任何的原子性保障措施的自增操作并不是原子性的。<br>如何保证原子性：</li>
<li>通过 synchronized 关键字保证原子性。</li>
<li>通过 Lock保证原子性。</li>
<li>通过 CAS保证原子性。</li>
</ul>
<h2 id="可见性问题深入分析"><a href="#可见性问题深入分析" class="headerlink" title="可见性问题深入分析"></a>可见性问题深入分析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class VisibilityTest &#123;</span><br><span class="line">    //  storeLoad  JVM内存屏障  ----&gt;  (汇编层面指令)  lock; addl <span class="variable">$0</span>,0(%%rsp)</span><br><span class="line">    // lock前缀指令不是内存屏障的指令，但是有内存屏障的效果   缓存失效</span><br><span class="line">    private volatile boolean flag = <span class="literal">true</span>;</span><br><span class="line">    private Integer count = 0;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">refresh</span></span>() &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改flag:&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">load</span></span>() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行.....&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            //TODO  业务逻辑</span><br><span class="line">            count++;</span><br><span class="line">            //JMM模型    内存模型： 线程间通信有关   共享内存模型</span><br><span class="line">            //没有跳出循环   可见性的问题</span><br><span class="line">            //能够跳出循环   内存屏障</span><br><span class="line">            //UnsafeFactory.getUnsafe().storeFence();</span><br><span class="line">            //能够跳出循环    ?   释放时间片，上下文切换   加载上下文：flag=<span class="literal">true</span></span><br><span class="line">            //Thread.yield();</span><br><span class="line">            //能够跳出循环    内存屏障</span><br><span class="line">            //System.out.println(count);</span><br><span class="line"></span><br><span class="line">            //LockSupport.unpark(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">            //shortWait(1000000); //1ms</span><br><span class="line">            //shortWait(1000);</span><br><span class="line"></span><br><span class="line">//            try &#123;</span><br><span class="line">//                Thread.sleep(1);   //内存屏障</span><br><span class="line">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line"></span><br><span class="line">            //总结：  Java中可见性如何保证？ 方式归类有两种：</span><br><span class="line">            //1.  jvm层面 storeLoad内存屏障    ===&gt;  x86   lock替代了mfence</span><br><span class="line">            // 2.  上下文切换   Thread.yield();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;跳出循环: count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VisibilityTest <span class="built_in">test</span> = new VisibilityTest();</span><br><span class="line"></span><br><span class="line">        // 线程threadA模拟数据加载场景</span><br><span class="line">        Thread threadA = new Thread(() -&gt; test.load(), <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        // 让threadA执行一会儿</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        // 线程threadB通过flag控制threadA的执行时间</span><br><span class="line">        Thread threadB = new Thread(() -&gt; test.refresh(), <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void shortWait(long interval) &#123;</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        long end;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125; <span class="keyword">while</span> (start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JMM内存模型.png</p>
<h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><h3 id="JMM定义"><a href="#JMM定义" class="headerlink" title="JMM定义"></a>JMM定义</h3><p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的<br>JMM.png</p>
<h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。<br>内存交互.png</li>
</ul>
<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：<br>1.如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。<br>2.不允许read和load、store和write操作之一单独出现<br>3.不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。<br>4.不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。<br>5.一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。<br>6.一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现<br>7.如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值<br>8.如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按程序类型，Java程序的内存可见性保证可以分为下列3类：</p>
<ul>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。 JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。</li>
</ul>
<p>JVM在32位处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性</p>
<h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>volatile的特性:<br>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性（基于这点，我们通过会认为volatile不具备原子性）。volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。<br>64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。</p>
<p>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性。</p>
<p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<h4 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h4><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
<h4 id="volatile可见性实现原理"><a href="#volatile可见性实现原理" class="headerlink" title="volatile可见性实现原理"></a>volatile可见性实现原理</h4><p>JMM内存交互层面实现<br>volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量操作对多线程的可见性。</p>
<p>硬件层面实现<br>通过lock前缀指令，会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<h4 id="volatile在hotspot的实现"><a href="#volatile在hotspot的实现" class="headerlink" title="volatile在hotspot的实现"></a>volatile在hotspot的实现</h4><p>字节码解释器实现:内存屏障</p>
<p>在linux系统x86中的实现：x86处理器中利用lock实现类似内存屏障的效果。</p>
<h4 id="lock前缀指令的作用"><a href="#lock前缀指令的作用" class="headerlink" title="lock前缀指令的作用"></a>lock前缀指令的作用</h4><ol>
<li>确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低<br>lock前缀指令的执行开销。</li>
<li>LOCK前缀指令具有类似于内存屏障的功能，禁止该指令与前面和后面的读写指令重排序。</li>
<li>LOCK前缀指令会等待它之前所有的指令完成、并且所有缓冲的写操作写回内存(也就是将store buffer中的内容写入内存)之后才开始执行，并且根据缓存一致性协议，刷新store buffer的操作会导致其他cache中的副本失效。</li>
</ol>
<h4 id="汇编层面volatile的实现"><a href="#汇编层面volatile的实现" class="headerlink" title="汇编层面volatile的实现"></a>汇编层面volatile的实现</h4><p>添加下面的jvm参数查看之前可见性Demo的汇编指令，使用了lock前缀指令实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">‐XX:+UnlockDiagnosticVMOptions ‐XX:+PrintAssembly ‐Xcomp</span><br></pre></td></tr></table></figure>

<p>指令重排序</p>
<p>Java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。<br>指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。在编译器与CPU处理器中都能执行指令重排优化操作<br>指令重排.png</p>
<p>volatile禁止重排序场景：</p>
<ol>
<li>第二个操作是volatile写，不管第一个操作是什么都不会重排序</li>
<li>第一个操作是volatile读，不管第二个操作是什么都不会重排序</li>
<li>第一个操作是volatile写，第二个操作是volatile读，也不会发生重排序</li>
</ol>
<p>内存屏障插入策略.png<br>JMM内存屏障插入策略</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ol>
<p>注意：x86处理器不会对读-读、读-写和写-写操作做重排序, 会省略掉这3种操作类型对应的内存屏障。仅会对写-读操作做重排序，所以volatile写-读操作只需要在volatile写后插入StoreLoad屏障</p>
<p>JVM层面的内存屏障<br>在JSR规范中定义了4种内存屏障：</p>
<ul>
<li>LoadLoad屏障：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>LoadStore屏障：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>StoreLoad屏障：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能由于x86只有store load可能会重排序，所以只有JSR的StoreLoad屏障对应它的mfence或lock前缀指令，其他屏障对应空操作。</li>
</ul>
<p>硬件层内存屏障<br>硬件层提供了一系列的内存屏障 memory barrier / memory fence(Intel的提法)来提供一致性的能力。拿X86平台来说，有几种主要的内存屏障：</p>
<ol>
<li>lfence，是一种Load Barrier 读屏障</li>
<li>sfence, 是一种Store Barrier 写屏障</li>
<li>mfence, 是一种全能型的屏障，具备lfence和sfence的能力</li>
<li>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC,AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB,XOR, XADD, and XCHG等指令。</li>
</ol>
<p>内存屏障有两个能力：</p>
<ol>
<li>阻止屏障两边的指令重排序</li>
<li>刷新处理器缓存/冲刷处理器缓存</li>
</ol>
<p>对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据；对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。<br>Lock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。<br>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码</p>
<p>CPU高速缓存（Cache Memory）<br>CPU缓存即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,减少CPU的等待时间，提高了系统的效率。</p>
<p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就是局部性原理。<br>时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。比如循环、递归、方法的反复调用等。</p>
<p>空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。</p>
<p>多CPU多核缓存架构<br>物理CPU：物理CPU就是插在主机上的真实的CPU硬件，在Linux下可以数不同的physical id 来确认主机的物理CPU个数。</p>
<p>核心数：我们常常会听说多核处理器，其中的核指的就是核心数。在Linux下可以通过cores来确认主机的物理CPU的核心数。</p>
<p>逻辑CPU：逻辑CPU跟超线程技术有联系，假如物理CPU不支持超线程的，那么逻辑CPU的数量等于核心数的数量；如果物理CPU支持超线程，那么逻辑CPU的数目是核心数数目的两倍。在Linux下可以通过 processors 的数目来确认逻辑CPU的数量。</p>
<p>现代CPU为了提升执行效率，减少CPU与内存的交互，一般在CPU上集成了多级缓存架构，常见的为三级缓存结构。</p>
<p>缓存一致性（Cache coherence）<br>计算机体系结构中，缓存一致性是共享资源数据的一致性，这些数据最终存储在多个本地缓存中。当系统中的客户机维护公共内存资源的缓存时，可能会出现数据不一致的问题，这在多处理系统中的cpu中尤其如此。<br>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据可能有多个副本:一个副本在主内存中，一个副本在请求它的每个处理器的本地缓存中。当数据的一个副本发生更改时，其他副本必须反映该更改。缓存一致性是确保共享操作数(数据)值的变化能够及时地<br>在整个系统中传播的规程。</p>
<p>缓存一致性的要求：<br>写传播（Write Propagation）对任何缓存中的数据的更改都必须传播到对等缓存中的其他副本(该缓存行的副本)。<br>事务串行化（Transaction Serialization）对单个内存位置的读/写必须被所有处理器以相同的顺序看到。理论上，一致性可以在加载/存储粒度上执行。然而，在实践中，它通常在缓存块的粒度上执行。<br>一致性机制（Coherence mechanisms</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-JVM内存模型深度剖析与优化</title>
    <url>/2022/02/20/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>JVM内存模型深度剖析与优化</p>
<span id="more"></span>

<p>JDK体系结构<br><img src="/images/JDK%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<p>Java语言的跨平台特性<br><img src="/images/Java%E8%B7%A8%E5%B9%B3%E5%8F%B0.png"></p>
<p>JVM怎么做到跨平台？<br>其实我们一开始下载JDK的时候我们就选择了平台，比如windows版本的JDK，Linux版本的JDK还有Mac等，不同的平台的JDK，里面就有特定该平台的JVM实现。</p>
<p>Java文件在JVM中执行<br><img src="/images/Java%E6%96%87%E4%BB%B6%E5%9C%A8JVM%E4%B8%AD%E6%89%A7%E8%A1%8C.png"></p>
<p>首先通过类加载机制（类装载子系统，c++实现），把我们的字节码文件丢到了Java虚拟机的内存区域，最后再通过我们的字节码执行引擎(c++实现)执行内存区域的代码。核心内容是图中第二块区域这里，调优这里是重点。</p>
<ul>
<li>类装载子系统：把字节码文件丢到了内存区。Class loader只管加载，只要符合文件结构就加载，至于能否运行，它不负责，那是有Exectution Engine 负责的</li>
<li>字节码执行引擎：执行内存区的代码</li>
<li>堆内存（线程共享）：new出来的对象一般放在堆。对象先放到eden区，当eden区对象放满时，字节码执行引擎会开始minor gc，如果是垃圾对象直接GC回收，如果是非垃圾对象就会复制到s0，一个对象如果经历过一次GC还存活着他的分代年龄会加1（分代年龄存在对象头），如果eden区又满了会在gc垃圾的对象，存活的对象会在s0跟s1轮流存放分代年龄增加，当分代年龄到了（一般15）会把这个对象挪到老年代。</li>
<li>栈(桶，线程)内存（线程私有）：存放局部变量。也可以称为线程栈，比如我们的main方法，只要有线程运行，Java虚拟机就会在线程栈内为当前线程开辟一个自己独立的内存空间，用来存放我们方法执行过程当中需要用到的局部变量，如果线程当中有多个方法，那么在栈内存当中就会一个方法一个栈帧（结构类似数组，除了放局部变量表，操作数栈，动态链接，方法出口）来隔开。根据数据结构栈的特点FILO，后进入的方法先执行完然后释放掉内存。栈中如果有局部变量是对象的话，那值是在堆里面，栈里面存的是对应堆里面的内存地址，看下面有两个箭头的图。</li>
<li>程序计数器（线程私有）：每一个线程独有的内存空间，跟栈一样，用来放我们程序正在运行或是马上就要运行的那一行代码的内存位置（行号），比如下面转汇编命令打开txt后里面compute()方法下的代码对应的数字0 1 2 3 。。。这样的数字，实际存的是这行代码在内存方法区中的地址。</li>
<li>方法区/元空间（线程共享）：常量池，静态变量，类信息，如果有些静态变量的值是对象，那么同样的那值是在堆里面，栈里面存的是对应堆里面的内存地址，看下面有两个箭头的图</li>
<li>本地方法栈（线程私有）：native方法，之前JDK很多都是C语言实现的，会找本地xxx.dll文件，跨源调用其他语言方法，相对于的方法执行也是要开辟内存，就放在本地方法栈中</li>
</ul>
<p>设计程序计数器的作用？<br>每次执行完一行代码，字节码执行引擎都会去修改程序计数器里面的值，当一个线程执行代码到一半时，突然被另外一个优先级更高的线程把cpu时间片抢过去，那这个线程就会被挂起，那等到下次恢复执行的时候就会从上次暂停的位置继续执行，而程序计数器就是记录这个位置的。</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%A0%88.png"></p>
<p>下图是代码例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line"></span><br><span class="line">public class Math &#123;</span><br><span class="line"></span><br><span class="line">    public static final int initData = 666;</span><br><span class="line">    public static TestOne one = new TestOne();</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">compute</span></span>() &#123; //一个方法对应一块栈帧内存区域</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int c = (a + b) * 10;</span><br><span class="line">        <span class="built_in">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Math math = new Math();</span><br><span class="line">        System.out.println(math.compute());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用javap命令把我们的Math.class文件（打开里面cafe babe开头）转为汇编指令查看，javap -v会更详细，运行好之后会显示常量池信息，放在我们的方法区，在这叫运行时常量池。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -c Math.class &gt;Math.txt</span><br></pre></td></tr></table></figure>
<p>查看txt文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Math.java&quot;</span></span><br><span class="line">public class com.study.Math &#123;</span><br><span class="line">  public static final int initData;</span><br><span class="line"></span><br><span class="line">  public static com.study.TestOne one;</span><br><span class="line"></span><br><span class="line">  public com.study.Math();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       4: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public int compute();</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_2</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: iadd</span><br><span class="line">       7: bipush        10</span><br><span class="line">       9: imul</span><br><span class="line">      10: istore_3</span><br><span class="line">      11: iload_3</span><br><span class="line">      12: ireturn</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           <span class="comment">#2                  // class com/study/Math</span></span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial <span class="comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       7: astore_1</span><br><span class="line">       8: getstatic     <span class="comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      11: aload_1</span><br><span class="line">      12: invokevirtual <span class="comment">#5                  // Method compute:()I</span></span><br><span class="line">      15: invokevirtual <span class="comment">#6                  // Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      18: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           <span class="comment">#7                  // class com/study/TestOne</span></span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial <span class="comment">#8                  // Method com/study/TestOne.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       7: putstatic     <span class="comment">#9                  // Field one:Lcom/study/TestOne;</span></span><br><span class="line">      10: <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们一个应用程序7x24小时运行时，肯定会不断产生新的对象，新的对象会存放在堆中，当堆中对象存放不下字节码执行引擎就会触发gc回收，释放掉无用的对象。</p>
<p>什么样的对象会最终到老年代？<br>静态变量引用的变量，比如对象池，缓存对象，spring容器里面的对象</p>
<p>在GC过程当中会触发STW（stop the world）事件，停止掉用户线程（用户操作发起的），minor gc是字节码引擎开启的后台线程，STW后用户使用会工具卡顿，影响体验和性能，主要还是减少full gc，因为full gc收集推信息时间较长，所以它的STM时间会长。</p>
<p>为什么要有STW机制（不停止掉用户线程）？<br> 因为gc过程当中就是为了找一些非垃圾对象。当发生full gc时，在找局部变量和静态变量过程当中，线程代码依然往下执行，当执行结束时，栈内存空间里面的局部变量线程一结束就会释放，占内存空间也会销毁掉，那之前堆中找的局部变量和静态变量对应的在栈中的指针也被销毁掉了，那他们就变成垃圾对象了，gc都没结束他们就变成垃圾对象，那之前的gc过程就白做了，所以在gc找对象的过程当中会让你不要变动。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-阻塞队列BlockingQueue实战及其原理分析</title>
    <url>/2022/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%AE%9E%E6%88%98%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>阻塞队列介绍</p>
<span id="more"></span>

<p>Queue接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">//添加一个元素，添加成功返回<span class="literal">true</span>, 如果队列满了，就会抛出异常</span><br><span class="line">boolean add(E e);</span><br><span class="line">//添加一个元素，添加成功返回<span class="literal">true</span>, 如果队列满了，返回<span class="literal">false</span></span><br><span class="line">boolean offer(E e);</span><br><span class="line">//返回并删除队首元素，队列为空则抛出异常</span><br><span class="line">E remove();</span><br><span class="line">//返回并删除队首元素，队列为空则返回null</span><br><span class="line">E poll();</span><br><span class="line">//返回队首元素，但不移除，队列为空则抛出异常</span><br><span class="line">E element();</span><br><span class="line">//获取队首元素，但不移除，队列为空则返回null</span><br><span class="line">E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockingQueue接口<br>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java5 中加入的。阻塞队列（BlockingQueue）是一个在队列基础上又支持了两个附加操作的队列，常用解耦。两个附加操作:</p>
<ul>
<li>支持阻塞的插入方法put: 队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法take: 队列空时，获取元素的线程会等待队列变为非空</li>
</ul>
<p>BlockingQueue和JDK集合包中的Queue接口兼容，同时在其基础上增加了阻塞功能。<br>入队：<br>（1）offer(E e)：如果队列没满，返回true，如果队列已满，返回false（不阻塞）<br>（2）offer(E e, long timeout, TimeUnit unit)：可以设置阻塞时间，如果队列已满，则进行阻塞。超过阻塞时间，则返回false<br>（3）put(E e)：队列没满的时候是正常的插入，如果队列已满，则阻塞，直至队列空出位置出队：<br>（1）poll()：如果有数据，出队，如果没有数据，返回null （不阻塞）<br>（2）poll(long timeout, TimeUnit unit)：可以设置阻塞时间，如果没有数据，则阻塞，超过阻塞时间，则返回null<br>（3）take()：队列里有数据会正常取出数据并删除；但是如果队列里无数据，则阻塞，直到队列里有数据</p>
<p>BlockingQueue常用方法示例<br>当队列满了无法添加元素，或者是队列空了无法移除元素时：</p>
<ol>
<li>抛出异常：add、remove、element</li>
<li>返回结果但不抛出异常：offer、poll、peek</li>
<li>阻塞：put、take</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>抛出异常</th>
<th>返回特定值</th>
<th>阻塞</th>
<th>阻塞特定时间</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>出队</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>获取队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>不支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>阻塞队列特性<br>阻塞<br>阻塞队列区别于其他类型的队列的最主要的特点就是“阻塞”这两个字，所以下面重点介绍阻塞功能：阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。实现阻塞最重要的两个方法是 take 方法和 put 方法。<br>take 方法<br>take 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 take 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。过程如图所示:<br>队列take方法.png<br>put 方法<br>put 方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队<br>列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空<br>间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到<br>队列中。过程如图所示：<br>队列put方法.png</p>
<p>是否有界<br>阻塞队列还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如 LinkedBlockingQueue 的上限是Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这<br>个容量装满。但是有的阻塞队列是有界的，例如 ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。<br>应用场景<br>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了，如图所示：<br>BlockingQueue应用场景.png</p>
<p>因为阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的，不会发生线程安全问题。生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开<br>发的难度和工作量。同时，队列它还能起到一个隔离的作用。比如说我们开发一个银行转账的程序，那么生产者线程不需要关心具体的转账逻辑，只需要把转账任务，如账户和金额等信息放到队列中就可以，而不需要去关心银行这个类如何实现具体的转账业务。而作为银行这个类来讲，它会去从队列里取出来将要执行的具体的任务，再去通过自己的各种方法来完成本次转账。这样就实现了具体任务与执行任务类之间的解耦，任务被放在了阻塞队列中，而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的，实现了隔离，提高了安全性。</p>
<p>常见阻塞队列<br>BlockingQueue 接口的实现类都被放在了 juc 包中，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>基于数组结构实现的一个有界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>基于链表结构实现的一个有界阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>支持按优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队 列</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>不存储元素的阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>基于链表结构实现的一个无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>基于链表结构实现的一个双端阻塞队列</td>
</tr>
</tbody></table>
<p>ArrayBlockingQueue<br>ArrayBlockingQueue是最典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用 ReentrantLock 实现线程安全。在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用ArrayBlockingQueue是个不错选择；当如果生产速度远远大于消费速度，则会导致队列填满，<br>大量生产线程被阻塞。<br>使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈<br>ArrayBlockingQueue.png</p>
<p>ArrayBlockingQueue使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BlockingQueue queue = new ArrayBlockingQueue(1024);</span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>); //向队列中添加元素</span><br><span class="line">Object object = queue.take(); //从队列中取出元素</span><br></pre></td></tr></table></figure>

<p>ArrayBlockingQueue的原理<br>数据结构<br>利用了Lock锁的Condition通知机制进行阻塞控制。<br>核心：一把锁，两个条件</p>
<p>LinkedBlockingQueue<br>LinkedBlockingQueue是一个基于链表实现的阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，由于这个数值特别大，所以 LinkedBlockingQueue 也被称作无界队列，代表它几乎没有界限，队列可以随着元素的添加而动态增长，但是如果没有剩余内存，<br>则队列将抛出OOM错误。所以为了避免队列过大造成机器负载或者内存爆满的情况出现，我们在使用的时候建议手动传一个队列的大小。<br>LinkedBlockingQueue内部由单链表实现，只能从head取元素，从tail添加元素。<br>LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞，添加元素和获取元素都有独立的锁，也就是说LinkedBlockingQueue是读写分离的，读写操作可以并行执行<br>LinkedBlockingQueue.png</p>
<p>LinkedBlockingQueue使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//指定队列的大小创建有界队列</span><br><span class="line">BlockingQueue&lt;Integer&gt; boundedQueue = new LinkedBlockingQueue&lt;&gt;(100);</span><br><span class="line">//无界队列</span><br><span class="line">BlockingQueue&lt;Integer&gt; unboundedQueue = new LinkedBlockingQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>LinkedBlockingQueue与ArrayBlockingQueue对比<br>LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：<br>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。<br>数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。<br>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影<br>响。<br>两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-JVM字节码文件结构深度剖析</title>
    <url>/2022/02/23/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p> Java中最多可以实现的接口数目：FFFF–&gt;   15x16^3 + 15x16^2 + 15x16^1+15=65535<br> <span id="more"></span></p>
<p> 常量池：可以理解是我们当前class的一个资源仓库，后面所有的操作都是去仓库拿地址来引用，后面其他操作就不需要再去把常量池定义出来，而是直接引用常量池中的常量，可以节省空间，类中的常量是在静态常量池，类加载的时候会加载到运行常量池中去。</p>
<p><img src="/images/Java%E4%B8%ADclass%E5%AD%97%E8%8A%82%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90.png"><br>图中2为静态常量池，3是元空间里面真正保存的数据</p>
<p>看下面代码分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String test2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.printLn(test1==test2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是true</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test1=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>;</span><br><span class="line">    String test2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.printLn(test1==test2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是true,在编译阶段就优化了，把”a”+”b”+”c”优化成”abc”，然后类加载阶段就会把”abc”放入运行时常量池中。<br>上面两段代码都是可以下图分析：<br><img src="/images/%E5%B8%B8%E9%87%8F%E6%B1%A01.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test2=new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String test1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.printLn(test1==test2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是false<br>看图下分析：<br><img src="/images/%E5%B8%B8%E9%87%8F%E6%B1%A02.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test2=new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String test1=new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.printLn(test1==test2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是false<br>看图下分析：<br><img src="/images/%E5%B8%B8%E9%87%8F%E6%B1%A03.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test1=new String(<span class="string">&quot;c&quot;</span>)+<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String test2=new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.printLn(test1==test2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是false<br>看图下分析：<br><img src="/images/%E5%B8%B8%E9%87%8F%E6%B1%A04.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test1=<span class="string">&quot;ab&quot;</span>+new String(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    String test2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String test3=test1.intern();</span><br><span class="line">    System.out.printLn(test1==test3)</span><br><span class="line">    System.out.printLn(test2==test3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是false和true,intern方法就是把一个字符串尝试放入运行时常量池，若运行时常量池中没有就添加进去，若有就返回常量池中的引用。<br>看图下分析：<br><img src="/images/%E5%B8%B8%E9%87%8F%E6%B1%A05.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-JVM指令手册</title>
    <url>/2022/02/20/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>JVM指令手册</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">栈和局部变量操作</span><br><span class="line">将常量压入栈的指令</span><br><span class="line">aconst_null 将null对象引用压入栈</span><br><span class="line">iconst_m1 将int类型常量-1压入栈</span><br><span class="line">iconst_0 将int类型常量0压入栈</span><br><span class="line">iconst_1 将int类型常量1压入操作数栈</span><br><span class="line">iconst_2 将int类型常量2压入栈</span><br><span class="line">iconst_3 将int类型常量3压入栈</span><br><span class="line">iconst_4 将int类型常量4压入栈</span><br><span class="line">iconst_5 将int类型常量5压入栈</span><br><span class="line">lconst_0 将long类型常量0压入栈</span><br><span class="line">lconst_1 将long类型常量1压入栈</span><br><span class="line">fconst_0 将<span class="built_in">float</span>类型常量0压入栈</span><br><span class="line">fconst_1 将<span class="built_in">float</span>类型常量1压入栈</span><br><span class="line">dconst_0 将double类型常量0压入栈</span><br><span class="line">dconst_1 将double类型常量1压入栈</span><br><span class="line">bipush 将一个8位带符号整数压入栈</span><br><span class="line">sipush 将16位带符号整数压入栈</span><br><span class="line">ldc 把常量池中的项压入栈</span><br><span class="line">ldc_w 把常量池中的项压入栈（使用宽索引）</span><br><span class="line">ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</span><br><span class="line">从栈中的局部变量中装载值的指令（局部变量表-》操作数栈）</span><br><span class="line">iload 从局部变量中装载int类型值</span><br><span class="line">lload 从局部变量中装载long类型值</span><br><span class="line">fload 从局部变量中装载<span class="built_in">float</span>类型值</span><br><span class="line">dload 从局部变量中装载double类型值</span><br><span class="line">aload 从局部变量中装载引用类型值（refernce）</span><br><span class="line">iload_0 从局部变量0中装载int类型值</span><br><span class="line">iload_1 从局部变量1中装载int类型值</span><br><span class="line">iload_2 从局部变量2中装载int类型值</span><br><span class="line">iload_3 从局部变量3中装载int类型值</span><br><span class="line">lload_0 从局部变量0中装载long类型值</span><br><span class="line">lload_1 从局部变量1中装载long类型值</span><br><span class="line">lload_2 从局部变量2中装载long类型值</span><br><span class="line">lload_3 从局部变量3中装载long类型值</span><br><span class="line">fload_0 从局部变量0中装载<span class="built_in">float</span>类型值</span><br><span class="line">fload_1 从局部变量1中装载<span class="built_in">float</span>类型值</span><br><span class="line">fload_2 从局部变量2中装载<span class="built_in">float</span>类型值</span><br><span class="line">fload_3 从局部变量3中装载<span class="built_in">float</span>类型值</span><br><span class="line">dload_0 从局部变量0中装载double类型值</span><br><span class="line">dload_1 从局部变量1中装载double类型值</span><br><span class="line">dload_2 从局部变量2中装载double类型值</span><br><span class="line">dload_3 从局部变量3中装载double类型值</span><br><span class="line">aload_0 从局部变量0中装载引用类型值</span><br><span class="line">aload_1 从局部变量1中装载引用类型值</span><br><span class="line">aload_2 从局部变量2中装载引用类型值</span><br><span class="line">aload_3 从局部变量3中装载引用类型值</span><br><span class="line">iaload 从数组中装载int类型值</span><br><span class="line">laload 从数组中装载long类型值</span><br><span class="line">faload 从数组中装载<span class="built_in">float</span>类型值</span><br><span class="line">daload 从数组中装载double类型值</span><br><span class="line">aaload 从数组中装载引用类型值</span><br><span class="line">baload 从数组中装载byte类型或boolean类型值</span><br><span class="line">caload 从数组中装载char类型值</span><br><span class="line">saload 从数组中装载short类型值</span><br><span class="line">将栈中的值存入局部变量的指令（操作数栈-》局部变量表）</span><br><span class="line">istore 将int类型值存入局部变量</span><br><span class="line">lstore 将long类型值存入局部变量</span><br><span class="line">fstore 将<span class="built_in">float</span>类型值存入局部变量</span><br><span class="line">dstore 将double类型值存入局部变量</span><br><span class="line">astore 将将引用类型或returnAddress类型值存入局部变量</span><br><span class="line">istore_0 将int类型值存入局部变量0</span><br><span class="line">istore_1 将int类型值存入局部变量1</span><br><span class="line">istore_2 将int类型值存入局部变量2</span><br><span class="line">istore_3 将int类型值存入局部变量3</span><br><span class="line">lstore_0 将long类型值存入局部变量0</span><br><span class="line">lstore_1 将long类型值存入局部变量1</span><br><span class="line">lstore_2 将long类型值存入局部变量2</span><br><span class="line">lstore_3 将long类型值存入局部变量3</span><br><span class="line">fstore_0 将<span class="built_in">float</span>类型值存入局部变量0</span><br><span class="line">fstore_1 将<span class="built_in">float</span>类型值存入局部变量1</span><br><span class="line">fstore_2 将<span class="built_in">float</span>类型值存入局部变量2</span><br><span class="line">fstore_3 将<span class="built_in">float</span>类型值存入局部变量3</span><br><span class="line">dstore_0 将double类型值存入局部变量0</span><br><span class="line">dstore_1 将double类型值存入局部变量1</span><br><span class="line">dstore_2 将double类型值存入局部变量2</span><br><span class="line">dstore_3 将double类型值存入局部变量3</span><br><span class="line">astore_0 将引用类型或returnAddress类型值存入局部变量0</span><br><span class="line">astore_1 将引用类型或returnAddress类型值存入局部变量1</span><br><span class="line">astore_2 将引用类型或returnAddress类型值存入局部变量2</span><br><span class="line">astore_3 将引用类型或returnAddress类型值存入局部变量3</span><br><span class="line">iastore 将int类型值存入数组中</span><br><span class="line">lastore 将long类型值存入数组中</span><br><span class="line">fastore 将<span class="built_in">float</span>类型值存入数组中</span><br><span class="line">dastore 将double类型值存入数组中</span><br><span class="line">aastore 将引用类型值存入数组中</span><br><span class="line">bastore 将byte类型或者boolean类型值存入数组中</span><br><span class="line">castore 将char类型值存入数组中</span><br><span class="line">sastore 将short类型值存入数组中</span><br><span class="line">wide指令</span><br><span class="line">wide 使用附加字节扩展局部变量索引</span><br><span class="line">通用(无类型）栈操作</span><br><span class="line">nop 不做任何操作</span><br><span class="line">pop 弹出栈顶端一个字长的内容</span><br><span class="line">pop2 弹出栈顶端两个字长的内容</span><br><span class="line">dup 复制栈顶部一个字长内容</span><br><span class="line">dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入</span><br><span class="line">栈</span><br><span class="line">dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入</span><br><span class="line">栈</span><br><span class="line">dup2 复制栈顶部两个字长内容</span><br><span class="line">dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入</span><br><span class="line">栈</span><br><span class="line">dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入</span><br><span class="line">栈</span><br><span class="line">swap 交换栈顶部两个字长内容</span><br><span class="line">类型转换</span><br><span class="line">i2l 把int类型的数据转化为long类型</span><br><span class="line">i2f 把int类型的数据转化为<span class="built_in">float</span>类型</span><br><span class="line">i2d 把int类型的数据转化为double类型</span><br><span class="line">l2i 把long类型的数据转化为int类型</span><br><span class="line">l2f 把long类型的数据转化为<span class="built_in">float</span>类型</span><br><span class="line">l2d 把long类型的数据转化为double类型</span><br><span class="line">f2i 把<span class="built_in">float</span>类型的数据转化为int类型</span><br><span class="line">f2l 把<span class="built_in">float</span>类型的数据转化为long类型</span><br><span class="line">f2d 把<span class="built_in">float</span>类型的数据转化为double类型</span><br><span class="line">d2i 把double类型的数据转化为int类型</span><br><span class="line">d2l 把double类型的数据转化为long类型</span><br><span class="line">d2f 把double类型的数据转化为<span class="built_in">float</span>类型</span><br><span class="line">i2b 把int类型的数据转化为byte类型</span><br><span class="line">i2c 把int类型的数据转化为char类型</span><br><span class="line">i2s 把int类型的数据转化为short类型</span><br><span class="line">整数运算</span><br><span class="line">iadd 执行int类型的加法</span><br><span class="line">ladd 执行long类型的加法</span><br><span class="line">isub 执行int类型的减法</span><br><span class="line">lsub 执行long类型的减法</span><br><span class="line">imul 执行int类型的乘法</span><br><span class="line">lmul 执行long类型的乘法</span><br><span class="line">idiv 执行int类型的除法</span><br><span class="line">ldiv 执行long类型的除法</span><br><span class="line">irem 计算int类型除法的余数</span><br><span class="line">lrem 计算long类型除法的余数</span><br><span class="line">ineg 对一个int类型值进行取反操作</span><br><span class="line">lneg 对一个long类型值进行取反操作</span><br><span class="line">iinc 把一个常量值加到一个int类型的局部变量上</span><br><span class="line">逻辑运算</span><br><span class="line">移位操作</span><br><span class="line">ishl 执行int类型的向左移位操作</span><br><span class="line">lshl 执行long类型的向左移位操作</span><br><span class="line">ishr 执行int类型的向右移位操作</span><br><span class="line">lshr 执行long类型的向右移位操作</span><br><span class="line">iushr 执行int类型的向右逻辑移位操作</span><br><span class="line">lushr 执行long类型的向右逻辑移位操作</span><br><span class="line">按位布尔运算</span><br><span class="line">iand 对int类型值进行“逻辑与”操作</span><br><span class="line">land 对long类型值进行“逻辑与”操作</span><br><span class="line">ior 对int类型值进行“逻辑或”操作</span><br><span class="line">lor 对long类型值进行“逻辑或”操作</span><br><span class="line">ixor 对int类型值进行“逻辑异或”操作</span><br><span class="line">lxor 对long类型值进行“逻辑异或”操作</span><br><span class="line">浮点运算</span><br><span class="line">fadd 执行<span class="built_in">float</span>类型的加法</span><br><span class="line">dadd 执行double类型的加法</span><br><span class="line">fsub 执行<span class="built_in">float</span>类型的减法</span><br><span class="line">dsub 执行double类型的减法</span><br><span class="line">fmul 执行<span class="built_in">float</span>类型的乘法</span><br><span class="line">dmul 执行double类型的乘法</span><br><span class="line">fdiv 执行<span class="built_in">float</span>类型的除法</span><br><span class="line">ddiv 执行double类型的除法</span><br><span class="line">frem 计算<span class="built_in">float</span>类型除法的余数</span><br><span class="line">drem 计算double类型除法的余数</span><br><span class="line">fneg 将一个<span class="built_in">float</span>类型的数值取反</span><br><span class="line">dneg 将一个double类型的数值取反</span><br><span class="line">对象和数组</span><br><span class="line">对象操作指令</span><br><span class="line">new 创建一个新对象</span><br><span class="line">checkcast 确定对象为所给定的类型</span><br><span class="line">getfield 从对象中获取字段</span><br><span class="line">putfield 设置对象中字段的值</span><br><span class="line">getstatic 从类中获取静态字段</span><br><span class="line">putstatic 设置类中静态字段的值</span><br><span class="line">instanceof 判断对象是否为给定的类型</span><br><span class="line">数组操作指令</span><br><span class="line">newarray 分配数据成员类型为基本上数据类型的新数组</span><br><span class="line">anewarray 分配数据成员类型为引用类型的新数组</span><br><span class="line">arraylength 获取数组长度</span><br><span class="line">multianewarray 分配新的多维数组</span><br><span class="line">控制流</span><br><span class="line">条件分支指令</span><br><span class="line">ifeq 如果等于0，则跳转</span><br><span class="line">ifne 如果不等于0，则跳转</span><br><span class="line">iflt 如果小于0，则跳转</span><br><span class="line">ifge 如果大于等于0，则跳转</span><br><span class="line">ifgt 如果大于0，则跳转</span><br><span class="line">ifle 如果小于等于0，则跳转</span><br><span class="line">if_icmpcq 如果两个int值相等，则跳转</span><br><span class="line">if_icmpne 如果两个int类型值不相等，则跳转</span><br><span class="line">if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</span><br><span class="line">if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</span><br><span class="line">if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</span><br><span class="line">if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</span><br><span class="line">ifnull 如果等于null，则跳转</span><br><span class="line">ifnonnull 如果不等于null，则跳转</span><br><span class="line">if_acmpeq 如果两个对象引用相等，则跳转</span><br><span class="line">if_acmpnc 如果两个对象引用不相等，则跳转</span><br><span class="line">比较指令</span><br><span class="line">lcmp 比较long类型值</span><br><span class="line">fcmpl 比较<span class="built_in">float</span>类型值（当遇到NaN时，返回-1）</span><br><span class="line">fcmpg 比较<span class="built_in">float</span>类型值（当遇到NaN时，返回1）</span><br><span class="line">dcmpl 比较double类型值（当遇到NaN时，返回-1）</span><br><span class="line">dcmpg 比较double类型值（当遇到NaN时，返回1）</span><br><span class="line">无条件转移指令</span><br><span class="line">goto 无条件跳转</span><br><span class="line">goto_w 无条件跳转（宽索引）</span><br><span class="line">表跳转指令</span><br><span class="line">tableswitch 通过索引访问跳转表，并跳转</span><br><span class="line">lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</span><br><span class="line">异常</span><br><span class="line">athrow 抛出异常或错误</span><br><span class="line">finally子句</span><br><span class="line">jsr 跳转到子例程</span><br><span class="line">jsr_w 跳转到子例程（宽索引）</span><br><span class="line">rct 从子例程返回</span><br><span class="line">方法调用与返回</span><br><span class="line">方法调用指令</span><br><span class="line">invokcvirtual 运行时按照对象的类来调用实例方法</span><br><span class="line">invokespecial 根据编译时类型来调用实例方法</span><br><span class="line">invokestatic 调用类（静态）方法</span><br><span class="line">invokcinterface 调用接口方法</span><br><span class="line">方法返回指令</span><br><span class="line">ireturn 从方法中返回int类型的数据</span><br><span class="line">lreturn 从方法中返回long类型的数据</span><br><span class="line">freturn 从方法中返回<span class="built_in">float</span>类型的数据</span><br><span class="line">dreturn 从方法中返回double类型的数据</span><br><span class="line">areturn 从方法中返回引用类型的数据</span><br><span class="line"><span class="built_in">return</span> 从方法中返回，返回值为void</span><br><span class="line">线程同步</span><br><span class="line">montiorenter 进入并获取对象监视器</span><br><span class="line">monitorexit 释放并退出对象监视器</span><br><span class="line">JVM指令助记符</span><br><span class="line">变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_</span><br><span class="line">操作数栈到变量：</span><br><span class="line">istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_</span><br><span class="line">常数到操作数栈：</span><br><span class="line">bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_</span><br><span class="line">加：iadd,ladd,fadd,dadd</span><br><span class="line">减：isub,lsub,fsub,dsub</span><br><span class="line">乘：imul,lmul,fmul,dmul</span><br><span class="line">除：idiv,ldiv,fdiv,ddiv</span><br><span class="line">余数：irem,lrem,frem,drem</span><br><span class="line">取负：ineg,lneg,fneg,dneg</span><br><span class="line">移位：ishl,lshr,iushr,lshl,lshr,lushr</span><br><span class="line">按位或：ior,lor</span><br><span class="line">按位与：iand,land</span><br><span class="line">按位异或：ixor,lxor</span><br><span class="line">类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)</span><br><span class="line">i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)</span><br><span class="line">创建类实便：new</span><br><span class="line">创建新数组：newarray,anewarray,multianwarray</span><br><span class="line">访问类的域和类实例域：getfield,putfield,getstatic,putstatic</span><br><span class="line">把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload</span><br><span class="line">从操作数栈存存储到数组：</span><br><span class="line">bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore</span><br><span class="line">获取数组长度：arraylength</span><br><span class="line">检相类实例或数组属性：instanceof,checkcast</span><br><span class="line">操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap</span><br><span class="line">有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,</span><br><span class="line">if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl</span><br><span class="line">fcmpg,dcmpl,dcmpg</span><br><span class="line">复合条件转移：tableswitch,lookupswitch</span><br><span class="line">无条件转移：goto,goto_w,jsr,jsr_w,ret</span><br><span class="line">调度对象的实便方法：invokevirtual</span><br><span class="line">调用由接口实现的方法：invokeinterface</span><br><span class="line">调用需要特殊处理的实例方法：invokespecial</span><br><span class="line">调用命名类中的静态方法：invokestatic</span><br><span class="line">方法返回：ireturn,lreturn,freturn,dreturn,areturn,<span class="built_in">return</span></span><br><span class="line">异常：athrow</span><br><span class="line">finally关键字的实现使用：jsr,jsr_w,ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-JVM调优实战及常量池详解</title>
    <url>/2022/03/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Arthas采用命令行交互模式，可以方便的定位和诊断，线上程序运行问题。<span id="more"></span>Arthas 官方文档十分详细，详见：<a href="https://alibaba.github.io/arthas%EF%BC%8C">https://alibaba.github.io/arthas，</a><br>用java -jar运行即可，可以识别机器上所有Java进程，以下面代码为例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">public class TestFour &#123;</span><br><span class="line">    static HashSet hashSet = new HashSet();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     // 模拟 CPU 过高</span><br><span class="line">     cpuHigh();</span><br><span class="line">     // 模拟线程死锁</span><br><span class="line">     deadThread();</span><br><span class="line">     // 不断的向 hashSet 集合增加数据</span><br><span class="line">     addHashSetThread();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     /*** 不断的向 hashSet 集合添加数据*/</span><br><span class="line">     public static void <span class="function"><span class="title">addHashSetThread</span></span>() &#123;</span><br><span class="line">         // 初始化常量</span><br><span class="line">         new Thread(() -&gt; &#123;</span><br><span class="line">                 int count = 0;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 hashSet.add(<span class="string">&quot;count&quot;</span> + count);</span><br><span class="line">                 Thread.sleep(1000);</span><br><span class="line">                 count++;</span><br><span class="line">                 &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).start();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     public static void <span class="function"><span class="title">cpuHigh</span></span>() &#123;</span><br><span class="line">         new Thread(() -&gt; &#123;</span><br><span class="line">                 <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).start();</span><br><span class="line">         &#125;</span><br><span class="line">    /* 死锁*/</span><br><span class="line">     private static void <span class="function"><span class="title">deadThread</span></span>() &#123;</span><br><span class="line">         /** 创建资源 */</span><br><span class="line">         Object resourceA = new Object();</span><br><span class="line">         Object resourceB = new Object();</span><br><span class="line">         // 创建线程</span><br><span class="line">         Thread threadA = new Thread(() -&gt; &#123;</span><br><span class="line">                 synchronized (resourceA) &#123;</span><br><span class="line">             System.out.println(Thread.currentThread() + <span class="string">&quot; get ResourceA&quot;</span>);</span><br><span class="line">             try &#123;</span><br><span class="line">                 Thread.sleep(1000);</span><br><span class="line">                 &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resourceB&quot;</span>);</span><br><span class="line">             synchronized (resourceB) &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread() + <span class="string">&quot; get resourceB&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">         Thread threadB = new Thread(() -&gt; &#123;</span><br><span class="line">                 synchronized (resourceB) &#123;</span><br><span class="line">             System.out.println(Thread.currentThread() + <span class="string">&quot; get ResourceB&quot;</span>);</span><br><span class="line">             try &#123;</span><br><span class="line">                 Thread.sleep(1000);</span><br><span class="line">                 &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resourceA&quot;</span>);</span><br><span class="line">             synchronized (resourceA) &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread() + <span class="string">&quot; get resourceA&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         threadA.start();</span><br><span class="line">         threadB.start();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arthas.png<br>选择进程序号1，进入我们对应的代码进程信息操作，输入dashboard可以查看整个进程的运行情况，线程、内存、GC、运行环境信息。<br>board.png<br>输入thread可以查看线程详细情况，输入 thread加上线程ID 可以查看线程堆栈，输入 thread -b 可以查看线程死锁<br>thread.png<br>输入jad加类的全名 可以反编译，这样可以方便我们查看线上代码是否是我们预期的那个版本<br>thread-b.png<br>使用 ognl 命令可以查看线上系统变量的值，甚至可以修改变量的值<br>ognl.png</p>
<p>GC日志详解：<br>于java应用我们可以通过一些配置把程序运行过程中的gc日志全部打印出来，然后分析gc日志得到关键性指标，分析GC原因，调优JVM参数。<br>打印GC日志方法，在JVM参数里增加参数，%t 代表时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">‐Xloggc:./gc‐%t.log ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause</span><br><span class="line">‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure>
<p>Tomcat则直接加在JAVA_OPTS变量里。</p>
<p>分析GC日志时在我们的运行程序加上对应gc日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar -Xloggc:./gc-%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCCause -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M microservice-eureka-server.jar</span><br></pre></td></tr></table></figure>

<p>gc日志.png<br>2022-03-04T15:48:42.002+0800: 2.334: [Full GC (Metadata GC Threshold) [PSYoungGen: 7422K-&gt;0K(283648K)] [ParOldGen: 104K-&gt;7139K(195072K)] 7526K-&gt;7139K(478720K), [Metaspace: 20807K-&gt;20807K(1069056K)], 0.0218388 secs] [Times: user=0.38 sys=0.03, real=0.02 secs] </p>
<p>我们可以看到CommandLine flags，是项目的配置参数。这里不仅配置了打印GC日志，还有相关的VM内存参数。<br>后面第一次full gc是在这个GC时间点发生GC之后相关GC情况。<br>1、对于2.334： 这是从jvm启动开始计算到这次GC经过的时间，前面还有具体的发生时间日期。<br>2、Full GC(Metadata GC Threshold)指这是一次full gc，括号里是gc的原因， PSYoungGen是年轻代的GC，<br>ParOldGen是老年代的GC，Metaspace是元空间的GC<br>3、 7422K-&gt;0K(283648K)，这三个数字分别对应GC之前占用年轻代的大小，GC之后年轻代占用，以及整个年轻代的大<br>小。<br>4、104K-&gt;7139K(195072K)，这三个数字分别对应GC之前占用老年代的大小，GC之后老年代占用，以及整个老年代的<br>大小。<br>5、7526K-&gt;7139K(478720K)，这三个数字分别对应GC之前占用堆内存的大小，GC之后堆内存占用，以及整个堆内存<br>的大小。<br>6、20807K-&gt;20807K(1069056K)，这三个数字分别对应GC之前占用元空间内存的大小，GC之后元空间内存占用，以<br>及整个元空间内存的大小。<br>7、0.0218388是该时间点GC总耗费时间。</p>
<p>从日志可以发现几次fullgc都是由于元空间不够导致的，所以我们可以将元空间调大点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar -Xloggc:./gc-%t.log -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCCause -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M microservice-eureka-server.jar</span><br></pre></td></tr></table></figure>
<p>gc调整元空间参数.png<br>发现已经没有因为元空间不够导致的fullgc了</p>
<p>对于CMS和G1参数配置如下：<br>CMS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">‐Xloggc:d:/gc‐cms‐%t.log ‐Xms50M ‐Xmx50M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:+PrintGCDetails ‐XX:+P</span><br><span class="line">rintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure>
<p>G1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">‐Xloggc:d:/gc‐g1‐%t.log ‐Xms50M ‐Xmx50M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:+PrintGCDetails ‐XX:+Pr</span><br><span class="line">intGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M ‐XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<p>JVM参数汇总查看命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">表示打印出所有参数选项的默认值</span><br><span class="line">java -XX:+PrintFlagsInitial </span><br><span class="line">表示打印出所有参数选项在运行程序时生效的值</span><br><span class="line">java -XX:+PrintFlagsFinal </span><br></pre></td></tr></table></figure>

<p>Class常量池与运行时常量池</p>
<p>常量池：可以理解是我们当前class的一个资源仓库，后面所有的操作都是去仓库拿地址来引用，后面其他操作就不需要再去把常量池定义出来，而是直接引用常量池中的常量，可以节省空间，类中的常量是在静态常量池，类加载的时候会加载到运行常量池中去。</p>
<p><img src="/images/Java%E4%B8%ADclass%E5%AD%97%E8%8A%82%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90.png"><br>图中2,4是常量池信息，3是元空间里面真正保存的数据,javap -v XXX.class命令对应图4，图2中constant cool下就是常量池信息，常量池中主要存放两大类常量：字面量和符号引用。</p>
<p>字面量<br>字面量就是指由字母、数字等构成的字符串或者数值常量，字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = <span class="string">&quot;ll&quot;</span>;</span><br><span class="line">int d = <span class="string">&quot;ll&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>符号引用<br>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<br>上面的a，b就是字段名称，就是一种符号引用，还有图4中常量池里的 com.xxx.xxx.Class 是类的全限定名，<br>main和compute是方法名称，()是一种UTF8格式的描述符，这些都是符号引用。这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装入内存就变成运行时常量池，对应的符号引用在程序加载或运行时会被转变为被加载到内存区域的代码的直接引用，也就是我们说的动态链接了。例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</li>
</ul>
<p>字符串常量池</p>
<p>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能,JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化,为字符串开辟一个字符串常量池，类似于缓存区,创建字符串常量时，首先查询字符串常量池是否存在该字符串存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    String test1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String test2=new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String test3=test1.intern();</span><br><span class="line">    System.out.println(test1==test2);//<span class="literal">false</span></span><br><span class="line">    System.out.println(test1==test3);//<span class="literal">true</span></span><br><span class="line">    System.out.println(test2==test3);//<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test1这种方式创建的字符串对象，只会在常量池中。因为有”abc”这个字面量，创建对象test1的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象,如果有，则直接返回该对象在常量池中的引用.如果没有，则会在常量池中创建一个新对象，再返回常量池中引用。</p>
<p>test2这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。<br>因为有”abc”这个字面量，所以会先检查字符串常量池中是否存在字符串”abc”，不存在，先在字符串常量池里创建一个字符串对象。再去内存中创建一个字符串对象”abc”，存在的话，就直接去堆内存中创建一个字符串对象”abc”，最后，将堆内存中的引用返回。</p>
<p>String中的intern方法是一个 native 的方法，当调用 intern方法时，如果池已经包含一个等于此String对象的字符串<br>（用equals(oject)方法确定），则返回池中的字符串。否则，将intern返回的引用指向当前字符串 test1(jdk1.6版本需要将<br>test1复制到字符串常量池里)。</p>
<p>字符串常量池位置<br>Jdk1.6及之前： 有永久代, 运行时常量池在永久代，运行时常量池包含字符串常量池<br>Jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里<br>Jdk1.8及之后： 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里</p>
<p>面试题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String test1 = new String(<span class="string">&quot;he&quot;</span>) + new String(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">String test2 = test1.intern();</span><br><span class="line">System.out.println(test1 == test2);</span><br><span class="line">// 在 JDK 1.6 下输出是 <span class="literal">false</span>，创建了 6 个对象</span><br><span class="line">// 在 JDK 1.7 及以上的版本输出是 <span class="literal">true</span>，创建了 5 个对象</span><br></pre></td></tr></table></figure>

<p>字符串池从永久代中脱离、移入堆区的原因，intern() 方法也相应发生了变化：<br><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0.png"><br>在 JDK 1.6 中，调用 intern() 首先会在字符串池中寻找 equal() 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用；假如字符串不存在，虚拟机会重新在永久代上创建一个实例，将 StringTable 的一个表项指向这个新创建的实例。<br>在 JDK 1.7 (及以上版本)中，由于字符串池不在永久代了，intern() 做了一些修改，更方便地利用堆中的对象。字符串存在时和 JDK 1.6一样，但是字符串不存在时不再需要重新创建实例，可以直接指向堆上的实例。</p>
<p>关于String是不可变的<br>通过上面例子可以得出得知：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String test1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>; //就等价于String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">String test2 = a + b + c;</span><br></pre></td></tr></table></figure>
<p>test2这个就不一样了，可以通过观察其JVM指令码发现test2的”+”操作会变成如下操作：<br>StringBuilder temp = new StringBuilder();<br>temp.append(a).append(b).append(c);<br>String test2 = temp.toString();</p>
<p>八种基本类型的包装类和对象池</p>
<p>java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫对象池，在堆上)，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大。</p>
<p>代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line"></span><br><span class="line">public class TestThree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a=127,b=127;</span><br><span class="line">        Integer c=128,d=128;</span><br><span class="line">        System.out.println(<span class="string">&quot;a==b?&quot;</span>+(a==b));//<span class="literal">true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a==b?&quot;</span>+(c==d));//<span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Integer的cache是-128到127，可以改，jvm启动参数能改上限，不能改下限，可以看IntegerCache类，下线值是固定常量。<br><img src="/images/IntegerCache.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-JVM调优工具详解及调优实战</title>
    <url>/2022/03/02/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>事先启动一个web应用程序，用jps查看其进程id，接着用各种jdk自带命令优化应用</p>
<span id="more"></span>


<p>Jmap命令</p>
<p>首先进入我们的目标目录，里面有个jar包，我们用java命令启动<br>jps.png</p>
<p>查看启动后本地进程，然后用jmap命令查看内存信息，实例个数以及占用内存大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br><span class="line">jmap -histo 74308 &gt;log.txt</span><br></pre></td></tr></table></figure>
<p>jmap.png</p>
<p>图中：</p>
<ul>
<li>num：序号</li>
<li>instances：实例数量</li>
<li>bytes：占用空间大小</li>
<li>class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</li>
</ul>
<p>查看堆信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -heap 74308</span><br></pre></td></tr></table></figure>
<p>堆信息.png</p>
<p>堆内存dump,把我们的堆信息dump成文件导出来放在当前目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=eureka.hprof 74308</span><br></pre></td></tr></table></figure>

<p>也可以用下面的参数设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)</p>
<ol>
<li>-XX:+HeapDumpOnOutOfMemoryError</li>
<li>-XX:HeapDumpPath=./ （路径）</li>
</ol>
<p>用jvisualvm命令工具导入该dump文件分析<br>jmap_dump.png</p>
<p>用jstack加进程id查找死锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line"></span><br><span class="line">public class TestFour &#123;</span><br><span class="line">        private static Object lock1 = new Object();</span><br><span class="line">        private static Object lock2 = new Object();</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 begin&quot;</span>);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                synchronized (lock2) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread2 begin&quot;</span>);</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    synchronized (lock1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码后控制台结果：<br>thread1 begin<br>main thread end<br>thread2 begin</p>
<p>jstack.png<br>“Thread-1” 线程名<br>prio=5 优先级=5<br>tid=0x000000001fa9e000 线程id<br>nid=0x2d64 线程对应的本地线程标识nid<br>java.lang.Thread.State: BLOCKED 线程状态</p>
<p>然后我们用jvisualvm自动检测死锁<br>jstack分析死锁.png</p>
<p>启动普通的jar程序JMX端口配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java ‐Dcom.sun.management.jmxremote.port=8888 ‐Djava.rmi.server.hostname=192.168.50.60 ‐Dcom.sun.management.jmxremot</span><br><span class="line">e.ssl=<span class="literal">false</span> ‐Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> ‐jar microservice‐eureka‐server.jar</span><br></pre></td></tr></table></figure>
<p>Dcom.sun.management.jmxremote.port 为远程机器的JMX端口<br>-Djava.rmi.server.hostname 为远程机器IP</p>
<p>tomcat的JMX配置：在catalina.sh文件里的最后一个JAVA_OPTS的赋值语句下一行增加如下配置行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;<span class="variable">$JAVA_OPTS</span> ‐Dcom.sun.management.jmxremote.port=8888 ‐Djava.rmi.server.hostname=192.168.50.60 ‐Dcom.sun.ma</span></span><br><span class="line"><span class="string">nagement.jmxremote.ssl=false ‐Dcom.sun.management.jmxremote.authenticate=false&quot;</span></span><br></pre></td></tr></table></figure>


<p>jstack找出占用cpu最高的线程堆栈信息<br>1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如74308<br>2，按H(shift+h)，获取每个线程的内存情况<br>3，找到内存和cpu占用最高的线程tid，比如74307<br>4，转为十六进制得到 12243，此为线程id的十六进制表示<br>5，执行 jstack 74308|grep -A 10 12243，得到线程堆栈信息中12243这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调<br>用方法<br>6，查看对应的堆栈信息找出可能存在问题的代码</p>
<p>Jinfo<br>查看正在运行的Java应用程序的扩展参数<br>查看jvm的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -flags 74900</span><br></pre></td></tr></table></figure>
<p>查看java系统参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -sysprops 74900</span><br></pre></td></tr></table></figure>

<p>jinfo.png</p>
<p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：<br>jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数]<br>注意：使用的jdk版本是jdk8<br>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况<br>jstat.png</p>
<p>垃圾回收统计:jstat -gc 74900<br>S0C：第一个幸存区的大小，单位KB<br>S1C：第二个幸存区的大小<br>S0U：第一个幸存区的使用大小<br>S1U：第二个幸存区的使用大小<br>EC：伊甸园区的大小<br>EU：伊甸园区的使用大小<br>OC：老年代大小<br>OU：老年代使用大小<br>MC：方法区大小(元空间)<br>MU：方法区使用大小<br>CCSC:压缩类空间大小<br>CCSU:压缩类空间使用大小<br>YGC：年轻代垃圾回收次数<br>YGCT：年轻代垃圾回收消耗时间，单位s<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间，单位s<br>GCT：垃圾回收消耗总时间，单位s</p>
<p>堆内存统计:jstat -gccapacity 74900<br>NGCMN：新生代最小容量<br>NGCMX：新生代最大容量<br>NGC：当前新生代容量<br>S0C：第一个幸存区大小<br>S1C：第二个幸存区的大小<br>EC：伊甸园区的大小<br>OGCMN：老年代最小容量<br>OGCMX：老年代最大容量<br>OGC：当前老年代大小<br>OC:当前老年代大小<br>MCMN:最小元数据容量<br>MCMX：最大元数据容量<br>MC：当前元数据空间大小<br>CCSMN：最小压缩类空间大小<br>CCSMX：最大压缩类空间大小<br>CCSC：当前压缩类空间大小<br>YGC：年轻代gc次数<br>FGC：老年代GC次数</p>
<p>新生代垃圾回收统计:jstat -gcnew 74900<br>S0C：第一个幸存区的大小<br>S1C：第二个幸存区的大小<br>S0U：第一个幸存区的使用大小<br>S1U：第二个幸存区的使用大小<br>TT:对象在新生代存活的次数<br>MTT:对象在新生代存活的最大次数<br>DSS:期望的幸存区大小<br>EC：伊甸园区的大小<br>EU：伊甸园区的使用大小<br>YGC：年轻代垃圾回收次数<br>YGCT：年轻代垃圾回收消耗时间</p>
<p>新生代内存统计:jstat -gcnewcapacity 74900<br>NGCMN：新生代最小容量<br>NGCMX：新生代最大容量<br>NGC：当前新生代容量<br>S0CMX：最大幸存1区大小<br>S0C：当前幸存1区大小<br>S1CMX：最大幸存2区大小<br>S1C：当前幸存2区大小<br>ECMX：最大伊甸园区大小<br>EC：当前伊甸园区大小<br>YGC：年轻代垃圾回收次数<br>FGC：老年代回收次数</p>
<p>老年代垃圾回收统计:jstat -gcold 74900<br>MC：方法区大小<br>MU：方法区使用大小<br>CCSC:压缩类空间大小<br>CCSU:压缩类空间使用大小<br>OC：老年代大小<br>OU：老年代使用大小<br>YGC：年轻代垃圾回收次数<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间<br>GCT：垃圾回收消耗总时间</p>
<p>老年代内存统计:jstat -gcoldcapacity 74900<br>OGCMN：老年代最小容量<br>OGCMX：老年代最大容量<br>OGC：当前老年代大小<br>OC：老年代大小<br>YGC：年轻代垃圾回收次数<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间<br>GCT：垃圾回收消耗总时间</p>
<p>元数据空间统计:jstat -gcmetacapacity 74900<br>MCMN:最小元数据容量<br>MCMX：最大元数据容量<br>MC：当前元数据空间大小<br>CCSMN：最小压缩类空间大小<br>CCSMX：最大压缩类空间大小<br>CCSC：当前压缩类空间大小<br>YGC：年轻代垃圾回收次数<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间<br>GCT：垃圾回收消耗总时间</p>
<p>E:\apache-tomcat-9.0.30&gt;jstat -gcutil 74900<br>S0：幸存1区当前使用比例<br>S1：幸存2区当前使用比例<br>E：伊甸园区使用比例<br>O：老年代使用比例<br>M：元数据区使用比例<br>CCS：压缩使用比例<br>YGC：年轻代垃圾回收次数<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间<br>GCT：垃圾回收消耗总时间</p>
<p>JVM运行情况预估</p>
<p>用jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的<br>JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p>
<p>年轻代对象增长的速率：<br>可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对<br>象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不<br>同的时间分别估算不同情况下对象增长速率。</p>
<p>Young GC的触发频率和每次耗时：<br>知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC<br>公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。</p>
<p>每次Young GC后有多少对象存活和进入老年代<br>这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。</p>
<p>Full GC的触发频率和每次耗时<br>知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。<br>优化思路其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年<br>代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p>
<p>内存泄露到底是怎么回事？<br>一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。<br>这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-垃圾收集器G1&amp;ZGC详解</title>
    <url>/2022/02/28/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1&amp;ZGC%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>G1收集器(-XX:+UseG1GC)</p>
<span id="more"></span>


<p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.<br><img src="/images/G1%E6%94%B6%E9%9B%86%E5%99%A8.png"></p>
<p>G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数-XX:G1HeapRegionSize手动指定Region大小，但是推荐默认的计算方式。<br>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p>
<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>
<p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p>
<ul>
<li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li>
<li>并发标记（Concurrent Marking）：同CMS的并发标记</li>
<li>最终标记（Remark，STW）：同CMS的重新标记</li>
<li>筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期<br>望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划.比如说老年代此时有1000个<br>Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得<br>知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集<br>合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但<br>是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老<br>年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样<br>回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片。(注意：CMS回收阶<br>段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了Shenandoah就实现了并<br>发收集，Shenandoah可以看成是G1的升级版本)</li>
</ul>
<p>G1被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点：<br>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短STW停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p>
<p>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</p>
<p>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</p>
<p>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”-XX:MaxGCPauseMillis”指定)内完成垃圾收集。</p>
<p>G1垃圾收集分类<br>YoungGC:Minor GC发生在Eden区；Young GC发生在Eden、S0、S1区；Major GC发生在Old区。<br>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时<br>间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young<br>GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC</p>
<p>MixedGC不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的<br>Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做<br>MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够<br>的空region能够承载拷贝对象就会触发一次Full GC</p>
<p>Full GC停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p>
<p>G1垃圾收集器优化建议?<br>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。<br>那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。所以这里核心还是在于调节-XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc.</p>
<p>什么场景适合使用G1</p>
<ul>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ul>
<p>ZGC收集器(-XX:+UseZGC)</p>
<p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器。</p>
<p>ZGC的目标主要有4个:</p>
<ul>
<li>支持TB量级的堆。我们生产环境的硬盘还没有上TB呢，这应该可以满足未来十年内，所有JAVA应用的需求。</li>
<li>最大GC停顿时间不超10ms。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。</li>
<li>奠定未来GC特性的基础。</li>
<li>最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</li>
</ul>
<p>重要的是它不分代(暂时):<br>单代，即ZGC「没有分代」。我们知道以前的垃圾回收器之所以分代，是因为源于大部分对象朝生夕死的假设，事实上大部分系统的对象分配行为也确实符合这个假设。那么为什么ZGC就不分代呢？因为分代实现起来麻烦，作者就先实现出一个比较简单可用的单代版本，后续会优化。</p>
<p>ZGC内存布局：<br>基于Region内存布局的， 暂时不设分代的， 使用了读屏障、 颜色指针等技术来实现可并发的标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。<br>ZGC的Region可以具有大、 中、 小三类容量：</p>
<ul>
<li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段， 稍后会介绍到）的， 因为复制一个大对象的代价非常高昂。</li>
</ul>
<p>ZGC是能自动感知NUMA架构并充分利用NUMA架构特性的。</p>
<p>颜色指针，Colored Pointers，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中。<br>每个对象有一个64位指针，这64位被分为：</p>
<ul>
<li>18位：预留给以后使用。</li>
<li>1位：Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过finalizer才能访问。</li>
<li>1位：Remapped标识，设置此位的值后，对象未指向relocation set中（relocation set表示需要GC的Region集合）。</li>
<li>1位：Marked1标识。</li>
<li>1位：Marked0标识，和上面的Marked1都是标记对象用于辅助GC。</li>
<li>42位：对象的地址（所以它可以支持2^42=4T内存）。</li>
</ul>
<p>为什么有2个mark标记？<br>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记。<br>GC周期1：使用mark0, 则周期结束所有引用mark标记都会成为01。<br>GC周期2：使用mark1, 则期待的mark标记10，所有引用都能被重新标记。<br>通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC就无法支持32位操作系统，同样的也就无法支持压缩指针了（CompressedOops，压缩指针也是32位）。</p>
<p>颜色指针的三大优势：</p>
<ol>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li>
<li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li>
<li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<p>ZGC运作过程：<br>并发标记（Concurrent Mark）：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记(Mark Start)和最终标记(Mark End)也会出现短暂的停顿，与G1不同的是， ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新染色指针中的Marked 0、 Marked 1标志位。</p>
<p>并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</p>
<p>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。ZGC的颜色指针因为“自愈”（Self‐Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。</p>
<p>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</p>
<p>ZGC存在的问题：<br>ZGC最大的问题是浮动垃圾。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。</p>
<p>解决方案<br>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<p>ZGC目前有4中机制触发GC：</p>
<ul>
<li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。</li>
<li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。</li>
<li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。</li>
<li>主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</li>
</ul>
<p>如何选择垃圾收集器</p>
<ol>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li>
<li>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</li>
</ol>
<p>注意：JDK 1.8默认使用 Parallel(年轻代和老年代都是)，JDK 1.9默认使用 G1</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-为Java开疆拓土的ZGC深度剖析</title>
    <url>/2022/03/08/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E4%B8%BAJava%E5%BC%80%E7%96%86%E6%8B%93%E5%9C%9F%E7%9A%84ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>ZGC出现背景</p>
<span id="more"></span>

<p>对于Java的项目来说，JVM进行垃圾回收会有一个很大的问题，就是STW，STW的全称是StopTheWorld。Java项目中，如果JVM要进行垃圾回收，会暂停所有的业务线程，也就是项目中的线程，这样会导致业务系统暂停。</p>
<p>垃圾回收器的发展<br>Java 的 GC 算法也在不停迭代，对于特定的应用，选择其最适合的 GC 算法，才能更高效的帮助业务实现其业务目标。对于这些延迟敏感的应用来说，GC 停顿已经成为阻碍 Java 广泛应用的一大顽疾，需要更适合的 GC 算法以满足这些业务的需求。<br>近些年来，服务器的性能越来越强劲，各种应用可使用的堆内存也越来越大，常见的堆大小从 10G 到百 G 级别，部分机型甚至可以到达 TB 级别，在这类大堆应用上，传统的 GC，如 CMS、G1 的停顿时间也跟随着堆大小的增长而同步增加，即堆大小指数级增长时，停顿时间也会指数级增长。特别是当触发 Full GC 时，停顿可达分钟级别(百GB级别的堆)。当业务应用需要提供高服务级别协议（Service Level Agreement，SLA），例如 99.99% 的响应时间不能超过 100ms，此时 CMS、G1 等就无法满足业务的需求。为满足当前应用对于超低停顿、并应对大堆和超大堆带来的挑战，伴随着 2018 年发布的 JDK 11，ZGC 应运而生。</p>
<p>ZGC（The Z Garbage Collector）是JDK 11中推出的一款追求极致低延迟的垃圾收集器，它曾经设计目标包括：</p>
<ul>
<li>停顿时间不超过10ms（JDK16已经达到不超过1ms）；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持8MB~4TB级别的堆，JDK15后已经可以支持16TB。<br>这么去想，如果使用ZGC来做Java项目，像对STW敏感的证券系统，游戏的系统都可以去用Java来做（以前都是C或者C++的市场），所以ZGC的出现就是为了抢占其他语言的市场（卷他们）。</li>
</ul>
<p>ZGC中的内存布局<br>为了细粒度地控制内存的分配，和G1一样，ZGC将内存划分成小的分区，在ZGC中称为页面（page）。ZGC中没有分代的概念（新生代、老年代）ZGC支持3种页面，分别为小页面、中页面和大页面。其中小页面指的是2MB的页面空间，中页面指32MB的页面空间，大页面指受操作系统控制的大页。</p>
<p>ZGC布局.png</p>
<p>当对象大小小于等于256KB时，对象分配在小页面。当对象大小在256KB和4M之间，对象分配在中页面。当对象大于4M，对象分配在大页面。ZGC对于不同页面回收的策略也不同。简单地说，小页面优先回收；中页面和大页面则尽量不回收。</p>
<p>为什么这么设计？<br>标准大页（huge page）是Linux Kernel 2.6引入的，目的是通过使用大页内存来取代传统的4KB内存页面，以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。<br>Huge pages 有两种格式大小：2MB 和1GB，2MB 页块大小适合用于GB大小的内存，1GB页块大小适合用于TB级别的内存，2MB 是默认的页大小。所以ZGC这么设置也是为了适应现代硬件架构的发展，提升性能。</p>
<p>了解下：ZGC是支持NUMA的，在进行小页面分配时会优先从本地内存分配，当不能分配时才会从远端的内存分配。对于中页面和大页面的分配，ZGC并没有要求从本地内存分配，而是直接交给操作系统，由操作系统找到一块能满足ZGC页面的空间。ZGC这样设计的目的在于，对于小页面，存放的都是小对象，从本地内存分配速度很快，且不会造成内存使用的不平衡，而中页面和大页面因为需要的空间大，如果也优先从本地内存分配，极易造成内存使用不均衡，反而影响性能。</p>
<p>ZGC的核心概念：指针着色技术（Color Pointers）<br>颜色指针可以说是ZGC的核心概念。因为他在指针中借了几个位出来做事情，所以它必须要求在64位的机器上才可以工作。并且因为要求64位的指针，也就不能支持压缩指针。ZGC中低42位表示使用中的堆空间，ZGC借几位高位来做GC相关的事情(快速实现垃圾回收中的并发标记、转移和重定位等)<br>颜色指针.png</p>
<p>ZGC流程：</p>
<ul>
<li>标记阶段(标识垃圾)</li>
<li>转移阶段(对象复制或移动)</li>
</ul>
<p>ZGC流程.png</p>
<p>根可达算法<br>来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>作为GC Roots的对象主要包括下面4种</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）：各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>方法区中类静态变量：java类的引用类型静态变量。</li>
<li>方法区中常量：比如：字符串常量池里的引用。</li>
<li>本地方法栈中JNI指针：（即一般说的Native方法）。</li>
</ul>
<p>ZGC中初始标记和并发标记<br>初始标记：从根集合(GC Roots)出发，找出根集合直接引用的活跃对象(根对象)<br>并发标记：根据初始标记找到的根对象，使用深度优先遍历对象的成员变量进行标记</p>
<p>ZGC基于指针着色的并发标记算法：</p>
<ul>
<li>初始阶段，在ZGC初始化之后，此时地址视图为Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动。</li>
<li>初始标记，这个阶段需要暂停（STW），初始标记只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，停顿时间不会随着堆的大小或者活跃对象的大小而增加。</li>
<li>并发标记，这个阶段不需要暂停（没有STW），扫描剩余的所有对象，这个处理时间比较长，所以走并发，业务线程与GC线程同时运行。但是这个阶段会产生漏标问题。</li>
<li>再标记，这个阶段需要暂停（没有STW），主要处理漏标对象，通过SATB算法解决（G1中的解决漏标的方案）。</li>
</ul>
<p>ZGC基于指针着色的并发转移算法：<br>ZGC的转移阶段</p>
<ul>
<li>并发转移准备(分析最有价值GC分页&lt;无STW &gt; )</li>
<li>初始转移（转移初始标记的存活对象同时做对象重定位&lt;有STW&gt; ）</li>
<li>并发转移（对转移并发标记的存活对象做转移&lt;无STW&gt;）</li>
</ul>
<p>并发转移.png<br>如何做到并发转移？<br>通过转发表(类似于HashMap)，用来存放新旧地址的地址指针，对象转移和插转发表做原子操作，对并发对象的地址指针做更新操作。</p>
<p>ZGC基于指针着色的重定位算法<br>并发标记对象的重定位，下次GC中的并发标记（在这个过程中会做上次并发标记对象的重定位，也就是我们漏标的对象给他们重新标记定位）<br>技术上：指针着色中M0和M1区分，比如最开始是M0那么下次就是M1，下下次再是M0，依次这样。<br>重定位算法.png</p>
<p>ZGC中的读屏障<br>涉及对象：并发转移但还没做对象重定位的对象（着色指针使用M0和M1可以区分）<br>触发时机：在两次GC之间业务线程访问这样的对象<br>触发操作：对象重定位+删除转发表记录（两个一起做原子操作）<br>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码，根据转发表把对象的地址指针更新为正确的，然后删掉转发表的对象地址记录（因为没用了）。</p>
<p>ZGC参数设置<br>ZGC 优势不仅在于其超低的 STW 停顿，也在于其参数的简单，绝大部分生产场景都可以自适应。当然，极端情况下，还是有可能需要对ZGC个别参数做个调整，大致可以分为三类：</p>
<ul>
<li>堆大小：Xmx。当分配速率过高，超过回收速率，造成堆内存不够时，会触发 Allocation Stall，这类 Stall 会减缓当前的用户线程。因此，当我们在 GC 日志中看到 Allocation Stall，通常可以认为堆空间偏小或者 concurrent gc threads 数偏小。</li>
<li>GC触发时机：ZAllocationSpikeTolerance, ZCollectionInterval。ZAllocationSpikeTolerance 用来估算当前的堆内存分配速率，在当前剩余的堆内存下，ZAllocationSpikeTolerance 越大，估算的达到OOM 的时间越快，ZGC 就会更早地进行触发 GC。ZCollectionInterval 用来指定 GC 发生的间隔，以秒为单位触发GC。</li>
<li>GC线程：ParallelGCThreads，ConcGCThreads。ParallelGCThreads 是设置STW任务的GC线程数目，默认为CPU个数的 60%；ConcGCThreads 是并发阶段GC线程的数目，默认为CPU个数的12.5%。增加GC线程数目可以加快GC完成任务，减少各个阶段的时间，但也会增加CPU的抢占开<br>销，可根据生产情况调整。由上可以看出ZGC需要调整的参数十分简单，通常设置Xmx即可满足业务的需求，大大减轻Java开发者的负<br>担。</li>
</ul>
<p>ZGC典型应用场景<br>因为ZGC不支持压缩指针和分代 GC，其内存占用相对于 G1 来说要稍大，在小堆情况下较为明显，而在大堆情况下，这些多占用的内存则显得不那么突出。因此，以下两类应用强烈建议使用 ZGC 来提升业务体验：</p>
<ul>
<li>超大堆应用。超大堆（百G以上）下，CMS 或者G1如果发生 Full GC，停顿会在分钟级别，可能会造成业务的终端，强烈推荐使用 ZGC。</li>
<li>当业务应用需要提供高服务级别协议（Service Level Agreement，SLA），例如 99.99% 的响应时间不能超过 100ms，此类应用无论堆大小，均推荐采用低停顿的 ZGC。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-从JDK源码级别彻底剖析JVM类加载机制</title>
    <url>/2022/02/19/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E4%BB%8EJDK%E6%BA%90%E7%A0%81%E7%BA%A7%E5%88%AB%E5%BD%BB%E5%BA%95%E5%89%96%E6%9E%90JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>从JDK源码级别彻底剖析JVM类加载机制</p>
<span id="more"></span>

<h2 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a>类加载运行全过程</h2><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到<br>JVM。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line"></span><br><span class="line">public class Math &#123;</span><br><span class="line"></span><br><span class="line">    public static final int initData = 666;</span><br><span class="line">    public static TestOne one = new TestOne();</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">compute</span></span>() &#123; //一个方法对应一块栈帧内存区域</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int c = (a + b) * 10;</span><br><span class="line">        <span class="built_in">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Math math = new Math();</span><br><span class="line">        System.out.println(math.compute());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java命令执行代码的大体流程如下：<br><img src="/images/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"><br>其中loadClass的类加载过程有如下几步：<br><strong>加载</strong> &gt;&gt; <strong>验证</strong> &gt;&gt; <strong>准备</strong> &gt;&gt; <strong>解析</strong> &gt;&gt; <strong>初始化</strong> &gt;&gt; 使用 &gt;&gt; 卸载</p>
<ul>
<li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的<br>main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的<br>java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
<li>验证：校验字节码文件的正确性</li>
<li>准备：给类的静态变量分配内存，并赋予默认值</li>
<li>解析：将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如<br>main()方法，修饰符，返回值等，理解为将方法名称当做符号)替换为指向数据所存内存的指针或句柄等(直接引用)，也就是这些方法加载到内存当中所在位置的地址，这个位置就是它的直接引用，这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用，可以看上面Math.java中main方法中的math.compute()这句代码，在加载的时候不会替换成内存地址，只有在运行时才会替换为直接引用。</li>
<li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li>
</ul>
<p>类被加载到方法区中后主要包含 运行时常量池、类型信息、字段信息、方法信息、类加载器的<br>引用、对应class实例的引用等信息。<br>类加载器的引用：这个类到类加载器实例的引用<br>对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。<br>注意，主类在运行过程中如果使用到其它类，会逐步加载这些类。<br>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。<br><img src="/images/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%BC%95%E7%94%A8.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    static int a=10;</span><br><span class="line">    int b=9;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Test的代码块！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态变量:&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例变量&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Test的静态代码块！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态变量:&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">Test</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是无参构造方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Add&#123;</span><br><span class="line">        static &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;首先加载的静态代码块是Add.class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">            Test <span class="built_in">test</span>=new Test();</span><br><span class="line">            A b = null; //A不会加载，除非这里执行 new A()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是A的静态代码块！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是A的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先加载的静态代码块是Add.class</span><br><span class="line">我是Test的静态代码块！</span><br><span class="line">静态变量:10</span><br><span class="line">我是Test的代码块！</span><br><span class="line">静态变量:10</span><br><span class="line">实例变量9</span><br><span class="line">我是无参构造方法！</span><br></pre></td></tr></table></figure>

<h2 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h2><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p>
<ul>
<li>引导类加载器(bootstrapLoader)：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如<br>rt.jar、charsets.jar等</li>
<li>扩展类加载器(extClassloader)：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR<br>类包</li>
<li>应用程序类加载器(appClassLoader)：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li>
<li>自定义加载器：负责加载用户自定义路径下的类包</li>
</ul>
<p>类加载器初始化过程：<br>类运行加载全过程会创建JVM启动器实例sun.misc.Launcher。<br>sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个sun.misc.Launcher实例。<br>在Launcher构造方法内部，其创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</p>
<p>双亲委派机制：<br><img src="/images/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png"><br>当加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载（即调用parent.loadClass(name, false);），如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到Math类，又向下退回Math类(调用当前类加载器的findClass方法来完成类加载。)的加载请求给应用程序类加载器，应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。</p>
<p>为什么要设计双亲委派机制？</p>
<ul>
<li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改</li>
<li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性<br>举个例子，我们自己写了一个类，包路径是java.lang，类名是string，然后运行main方法<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">         public class String &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;运行结果！&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
会发现报错了，在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.Application<br>解释：首先会通过我们的appClassLoader加载，发现没有会往上去父加载器去找，直到在bootstrapLoader加载器找到了这个类，但是这个类里面没有main方法，导致报错了。所以像我们自己写的同名核心String类是不会被加载的，防止恶意篡改。</li>
</ul>
<p>全盘负责委托机制：<br>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。比如上面的Math类，当已经加载到了这个类后，无法避免会加载TestOne类，那这个类就由加载Math的加载器（当时是由appClassLoader，就只会由它来加载）来负责加载。</p>
<p>自定义类加载器示例：<br>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写findClass方法。</p>
<p>打破双亲委派机制：<br>用自定义类加载器，重写类加载方法，实现自己的加载逻辑，不委派给双亲加载，在第一次加载的时候就不往上，自己去加载。</p>
<p>Tomcat打破双亲委派机制：<br>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？<br>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的<br>不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是<br>独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程<br>序，那么要有10份相同的类库加载进虚拟机。</li>
<li>web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的<br>类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中<br>运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</li>
</ol>
<p>Tomcat为什么要打破双亲委派机制：<br>当tomcat上面有多个war包，war包里面的Spring版本不同时，如果没有隔离，这边war包是要高版本支持，加载引用时却加载到的低版本，会导致出问题，所以tomcat是要实现打破双亲委派，并且各个war包应用程序是相互隔离的互不影响的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优-垃圾收集器ParNew&amp;CMS与底层三色标记算法详解</title>
    <url>/2022/02/25/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew&amp;CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>垃圾收集器ParNew&amp;CMS与底层三色标记算法详解</p>
<span id="more"></span>


<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h4 id="1-1-分代收集理论"><a href="#1-1-分代收集理论" class="headerlink" title="1.1 分代收集理论"></a>1.1 分代收集理论</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
<h4 id="1-2-标记-复制算法"><a href="#1-2-标记-复制算法" class="headerlink" title="1.2 标记-复制算法"></a>1.2 标记-复制算法</h4><p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="/images/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p>
<h4 id="1-3-标记-整理算法"><a href="#1-3-标记-整理算法" class="headerlink" title="1.3 标记-整理算法"></a>1.3 标记-整理算法</h4><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存，不会出现回收后空间零零碎碎。<br><img src="/images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p>
<h4 id="1-4-标记-清除算法"><a href="#1-4-标记-清除算法" class="headerlink" title="1.4 标记-清除算法"></a>1.4 标记-清除算法</h4><p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标<br>记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来<br>两个明显的问题：</p>
<ul>
<li>效率问题 (如果需要标记的对象太多，效率不高)</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）<br><img src="/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</p>
<h4 id="1-1-Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a href="#1-1-Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC" class="headerlink" title="1.1 Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)"></a>1.1 Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</h4><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。新生代采用复制算法，老年代采用标记-整理算法。</p>
<h4 id="1-2-Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><a href="#1-2-Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代" class="headerlink" title="1.2 Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))"></a>1.2 Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</h4><p>Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。<br>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。新生代采用复制算法，老年代采用标记-整理算法。</p>
<h4 id="1-3-ParNew收集器-XX-UseParNewGC"><a href="#1-3-ParNew收集器-XX-UseParNewGC" class="headerlink" title="1.3 ParNew收集器(-XX:+UseParNewGC)"></a>1.3 ParNew收集器(-XX:+UseParNewGC)</h4><p>ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。新生代采用复制算法，老年代采用标记-整理算法。<br>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<h4 id="1-4-CMS收集器-XX-UseConcMarkSweepGC-old"><a href="#1-4-CMS收集器-XX-UseConcMarkSweepGC-old" class="headerlink" title="1.4 CMS收集器(-XX:+UseConcMarkSweepGC(old))"></a>1.4 CMS收集器(-XX:+UseConcMarkSweepGC(old))</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<br>整个过程分为以下几个步骤：</p>
<ul>
<li>初始标记：暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。</li>
<li>并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，不会STW， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li>重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。</li>
<li>并发清理：开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。</li>
<li>并发重置：重置本次GC过程中的标记数据。</li>
</ul>
<p>主要优点：并发收集、低停顿。但是它有下面几个明显的缺点：</p>
<ul>
<li>对CPU资源敏感（会和服务抢资源）。</li>
<li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)。</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理。</li>
<li>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收。</li>
</ul>
<p>CMS的相关核心参数</p>
<ol>
<li>-XX:+UseConcMarkSweepGC：启用cms</li>
<li>-XX:ConcGCThreads：并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</li>
<li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</li>
<li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段</li>
<li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li>
</ol>
<h3 id="垃圾收集底层算法实现"><a href="#垃圾收集底层算法实现" class="headerlink" title="垃圾收集底层算法实现"></a>垃圾收集底层算法实现</h3><p>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里我们引入“三色标记”来给大家解释下，把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描<br>过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过<br>灰色对象） 指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
</ul>
<p><img src="/images/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.png"></p>
<p>多标-浮动垃圾：<br>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>
<p>漏标-读写屏障：<br>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（IncrementalUpdate） 和原始快照（Snapshot At The Beginning，SATB） 。</p>
<p>增量更新：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</p>
<p>原始快照：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。</p>
<p>写屏障：我们可以按照aop来理解，其实就是指在赋值操作前后，加入一些处理。<br>写屏障的作用：</p>
<ul>
<li>写屏障实现SATB，成员变量的引用发生变化时，比如引用消失（赋值为null），我们可以利用写屏障，将原来成员变量的引用对象记录下来。</li>
<li>写屏障实现增量更新，当对象的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A新的成员变量引用对象D<br>记录下来。</li>
</ul>
<p>读屏障：读屏障是直接针对并发标记一开始读取成员变量时，都记录下来。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客</title>
    <url>/2022/01/14/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9cdf9c4beab5386a129d46b455463ab406df7deeb5d2c69fa0dac5699b4462ad">4630436162ade97ba2718b7d0c4b3b63673a2f41305796001771d77f5c3bca5f6e47e18c0bcc932126c42a841eddd6ace54ab0b5d60e5d6a6b629428c2d4c54bdaef1a42e6a939064f15a810cf2d51b30ec72222682b706dfc9f5c30c7a16a3eb685c3adfff55b9f4483b4c9f0fb4e0dc842b2ae0bb05c23bf7c88f7f620ae7d51e6574a8ff20c30582786986958b6b7a6f3f34c0fc96a960edd4d91170202d68bfbc22f767fca7dfbc8e33673a20e035ac498b5509d4acdca2263e31b33d81032b5838a373c6f9a347dff9980b4b7eb96e185c39497e09b37b80534c710edcbd58ca698d98a78d86c796d4d6207837c3602c977a983085e4757364b26873a099a2bd139ed7241a2817f749dfecb219faf15703f5f07dfff3d703880f52dc390d76bc845039ebf5b192374a3b70cd5625d6b841faa84db9c27b9e17e6b830807845c680ddb3310c13014d281c37c31926c2dbf99f1ea4541cf00f0f0c0e63e928fee478fc24333a4d6b5f1ba294e6605fbeee999198a9a1ce9ea9ca3b21ea219948fe9dfc63ca3b88acc891692f57d7b2f68619d6a16a1e30b5d44b720b279bb490d132538396b3a255fd567ee7e3b6cc61b71bc0b2aa838ec2a11e3dfd07d958e666151af9f0d921bb3fde385768de864a8674fb578e4739848e115547d60c9a6889f089d0cf3dd13873b005c6e218aa184164d315e308988888140599a8fa1f9ad4d8855d36412fe7e030dbe3149d8a43e371c2ea2c57659854666c72dd404b7b10aa9fc7b8f9cd0d34c1eaf683b603b5370c14d69a49e6441164aeaf3e2519c62eae644efb877a27e1ce4600bf1fde0ab2bf4047f4114dff4ee2a1e1001f3270f624c745b7da459ed5c564838e2e61d9e1a104e1bf50225a765174ee8fcdfbecab056dc4627e984171d4da1907828e06f393addbc591179e96211c19bad38b6ebe7d79e3cdf0e3d7855ee3f6901326ee050c6995a3ea3487ddc8f529c2fd83e22afe63fd09fda22811c7f344028111a095c66c39a996673ac3b1ae670c187283b7956e328df1d7e07a35f22d04c71acaa65b5ef05e223dc8079dbb07f830f657c563d28a91714a04da53cc4180eeefe88c312a5993df86506902e3f3a6009ffaabd57745bcf6ae9a909a45ae7a7ce7c171fb0b1d08766029413c00c81d443070937a6772eaee18396ea1e15a323c940d9a30bb400a2006edab2f7f898f9d36848e4957110a0d3e025475c52ccc87d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础系列-冯诺依曼和哈佛</title>
    <url>/2022/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E5%92%8C%E5%93%88%E4%BD%9B/</url>
    <content><![CDATA[<p>冯诺依曼和哈佛</p>
<span id="more"></span>
<h2 id="一-冯诺依曼和哈佛"><a href="#一-冯诺依曼和哈佛" class="headerlink" title="一.冯诺依曼和哈佛"></a>一.冯诺依曼和哈佛</h2><h4 id="1-1-冯诺依曼体系结构概述"><a href="#1-1-冯诺依曼体系结构概述" class="headerlink" title="1.1 冯诺依曼体系结构概述"></a>1.1 冯诺依曼体系结构概述</h4><p>数学家冯·诺依曼提出了计算机制造的三个基本原则（采用二进制、程序存储、顺序执行），以及计算机的五个组成部分（运算器、控制器、存储器、输入设备、输出设备），它们之间以总线相连,这套理论被称为冯·诺依曼体系结构，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。</p>
<p>冯·诺依曼最先提出程序存储的思想，并成功将其运用在计算机的设计之中。冯·诺伊曼体系结构是现代计算机的基础，现在大多计算机仍是冯·诺伊曼计算机的组织结构，因此冯·诺依曼又被称为“现代计算机之父”。<br><img src="/images/fnymjg.png"></p>
<p>冯·诺依曼体系结构特点：</p>
<ul>
<li>（1）计算机处理的数据和指令一律用二进制数表示。</li>
<li>（2）指令和数据不加区别混合存储在同一个 存储器 中（硬盘）</li>
<li>（3）顺序执行程序的每一条指令。(重点是“顺序”)</li>
</ul>
<p>冯·诺依曼体系结构的计算机必须具备功能：</p>
<ul>
<li>（1）把需要的程序和数据送至计算机中（复制）</li>
<li>（2）必须具有长期记忆程序、数据、中间结果及最终运算结果的能力（硬盘）</li>
<li>（3）能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力（ALU）</li>
<li>（4）能够根据需要控制程序的走向，并能根据指令控制机器的各部件协调操作。</li>
<li>（5）能够按照要求将处理的结果输出给用户。</li>
</ul>
<p>下面分例子来源：<a href="https://blog.csdn.net/chenkaibsw/article/details/78315931">https://blog.csdn.net/chenkaibsw/article/details/78315931</a><br>通过执行一个简单相加指令举例：<br><img src="/images/zllz.png"></p>
<p>举例：存储器中一条命令，假设这条命令执行这样一条动作，ADD  123  321，ADD表示要做的事情（相加），后面是参数相加动作的两个数，</p>
<ul>
<li><p>（1）通过命令记录员找到当前执行到的命令，并将命令提取出来放到命令控制器中的指令暂存处</p>
</li>
<li><p>（2）接着控制器中的命令解释器对命令进行解释，并将解释结果传给控制信号产生器产生相应的控制信号</p>
</li>
<li><p>（3）在控制器的控制下，将两个数再从存储器中提取出来，分别放到运算器的两个数据缓存区中（数据暂存）</p>
</li>
<li><p>（4）接着控制器产生一个控制信号告诉电路做这两个数的加法，相加得到运算结果.</p>
</li>
</ul>
<p>总结：控制器从存储器取出一条命令，然后对命令进行解析，按照命令的要求把相应参与运算的数据取出，放到运算器，运算器计算获得结果,最后输出到输出设备上.执行完这条命令后，转到下一条命令继续执行。</p>
<h4 id="1-2-冯诺依曼体系工作原理-cpu工作原理"><a href="#1-2-冯诺依曼体系工作原理-cpu工作原理" class="headerlink" title="1.2 冯诺依曼体系工作原理(cpu工作原理)"></a>1.2 冯诺依曼体系工作原理(cpu工作原理)</h4><p>程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程。冯·诺依曼型计算机从本质上讲是采用串行顺序处理的工作机制，即使有关数据已经准备好了，也必须逐条执行指令序列<br><img src="/images/cxzx.png"></p>
<p>具体过程：</p>
<ul>
<li>（1）预先把指挥计算机如何进行操作的指令序列（就是程序）和原始数据输入到计算机内存中（拷贝），每条指令中明确规定了计算机从哪个地址取数，进行什么操作，然后送到什么地方去等步骤。</li>
<li>（2）计算机在执行时，先从内存中取出第一条指令，通过控制器的译码器接收指令的要求，再从存储器中取出数据进行指定的运算和逻辑操作等，然后再按地址把结果送到内存中，如果需要向硬盘等存储设备存储数据，还需要将内存中的该数据存储到硬盘中。接下来取出第2条指令，在控制器的指挥下完成规定操作，依次进行下去，直到遇到停止指令。</li>
<li>（3）计算机中基本上有两股信息在流动，一种是数据，即各种原始数据、中间结果和程序等，另一种信息是控制信息，它控制机器的各种部件执行指令规定的各种操作。<br><img src="/images/jlztcs.png"></li>
</ul>
<h4 id="1-3-哈佛结构"><a href="#1-3-哈佛结构" class="headerlink" title="1.3 哈佛结构"></a>1.3 哈佛结构</h4><p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。</p>
<h4 id="1-4-哈佛结构和冯诺依曼结构的区别"><a href="#1-4-哈佛结构和冯诺依曼结构的区别" class="headerlink" title="1.4 哈佛结构和冯诺依曼结构的区别"></a>1.4 哈佛结构和冯诺依曼结构的区别</h4><p>哈佛结构和冯诺依曼结构主要区别在是否区分指令与数据。实际上在内存里，指令和数据是在一起的。而在CPU内的缓存中，还是会区分指令缓存和数据缓存，最终执行的时候，指令和数据是从两个不同的地方出来的。在CPU外部，采用的是冯诺依曼模型，而在CPU内部用的是哈佛结构。大部分的DSP都没有缓存，因而直接就是哈佛结构。哈佛结构设计复杂，但效率高。冯诺依曼结构则比较简单，但也比较慢。CPU厂商为了提高处理速度，在CPU内增加了高速缓存。也基于同样的目的，区分了指令缓存和数据缓存。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础系列-计算机基本组成</title>
    <url>/2022/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<p>计算机硬件系统均由运算器、控制器、存储器、输入设备和输出设备五大部分构成。</p>
<span id="more"></span>
<h2 id="一-计算机的基本硬件组成"><a href="#一-计算机的基本硬件组成" class="headerlink" title="一.计算机的基本硬件组成"></a>一.计算机的基本硬件组成</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png"></p>
<ul>
<li><p>1、运算器：算术运算和逻辑运行的实际执行部件。</p>
</li>
<li><p>2、控制器：统一指挥和控制计算机各部件按时序协调操作的部件。</p>
</li>
<li><p>3、内部存储器按其存储信息的方式可以分为只读存储器ROM(Read Only Memory)、随机存储器RAM(Random Access Memory)和高速缓冲存储器Cache。</p>
</li>
<li><p>4、输入设备：键盘、鼠标、扫描仪、光笔。</p>
</li>
<li><p>5、输出设备：显示器、音箱、打印机、绘图仪。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.png"><br>详细内容：<a href="https://blog.csdn.net/sunshine_hsm/article/details/81536509">https://blog.csdn.net/sunshine_hsm/article/details/81536509</a></p>
</li>
</ul>
<h4 id="1-1-cpu"><a href="#1-1-cpu" class="headerlink" title="1.1 cpu"></a>1.1 cpu</h4><p> 中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%99%A8/2206126">控制器</a>、<a href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E5%99%A8/2667320">运算器</a>，其中还包括<a href="https://baike.baidu.com/item/%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/9027270">高速缓冲存储器</a>及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。</p>
<p>在计算机体系结构中，CPU 是对计算机的所有硬件资源（如存储器、输入输出单元） 进行控制调配、执行通用运算的核心硬件单元。CPU 是计算机的运算和控制核心。计算机系统中所有软件层的操作，最终都将通过指令集映射为CPU的操作。</p>
<h4 id="1-2-内存"><a href="#1-2-内存" class="headerlink" title="1.2 内存"></a>1.2 内存</h4><p>内存(Memory)是<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>的重要部件之一，也称<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%82%A8%E5%99%A8/834392">内存储器</a>和<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/10635399">主存储器</a>，它用于暂时存放CPU中的运算数据，与<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98/159825">硬盘</a>等<a href="https://baike.baidu.com/item/%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/4843180">外部存储器</a>交换的数据。它是<a href="https://baike.baidu.com/item/%E5%A4%96%E5%AD%98/2445612">外存</a>与<a href="https://baike.baidu.com/item/CPU/120556">CPU</a>进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</p>
<p>内存的运行也决定计算机整体运行快慢的程度。</p>
<h4 id="1-3-主板"><a href="#1-3-主板" class="headerlink" title="1.3 主板"></a>1.3 主板</h4><p>主板，也叫母板，安装在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>主机箱内，是计算机最基本也是最重要的部件之一，在整个计算机系统中扮演着举足轻重的角色。主板制造质量的高低，决定了硬件系统的稳定性。主板与CPU关系密切，每一次CPU的重大升级，必然导致主板的换代。主板是计算机<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6/479446">硬件</a>系统的核心，也是主机箱内面积最大的一块<a href="https://baike.baidu.com/item/%E5%8D%B0%E5%88%B7%E7%94%B5%E8%B7%AF%E6%9D%BF/10690193">印刷电路板</a>。主板的主要功能是传输各种电子信号，部分芯片也负责初步处理一些外围数据。计算机主机中的各个部件都是通过主板来连接的，计算机在正常运行时对系统内存、存储设备和其他<a href="https://baike.baidu.com/item/I%2FO%E8%AE%BE%E5%A4%87/9688581">I/O设备</a>的操控都必须通过主板来完成。计算机性能是否能够充分发挥，硬件功能是否足够，以及硬件兼容性如何等，都取决于主板的设计。主板的优劣在某种程度上决定了一台计算机的整体性能、使用年限以及功能扩展能力 。</p>
<p>主板采用了开放式结构。主板上大都有6-15个扩展插槽，供<a href="https://baike.baidu.com/item/PC/107">PC</a>机外围设备的控制卡（<a href="https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8/908851">适配器</a>）插接。通过更换这些插卡，可以对微机的相应子系统进行局部升级，使厂家和用户在配置机型方面有更大的灵活性。总之，主板在整个<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%9C%BA%E7%B3%BB%E7%BB%9F/2852578">微机系统</a>中扮演着举足轻重的角色。可以说，主板的类型和档次决定着整个微机系统的类型和档次，主板的性能影响着整个微机系统的性</p>
<h4 id="1-4-I-O设备"><a href="#1-4-I-O设备" class="headerlink" title="1.4 I/O设备"></a>1.4 I/O设备</h4><p>计算机的IO设备非常多，键盘、鼠标、感应屏幕、显示器、网卡、U盘、打印机。</p>
<p>提前需要说明的一点就是，IO设备中最核心的一点就是中断处理。这在单片机中也是最核心的一块内容。具体开辟一章blog来写控制，这里就只总结IO相关的东西。</p>
<ul>
<li><p>IO结构<br>最早的IO要先和CPU通信，和主存的连接是间接的。现在发展成为经过一个IO接口，直接接到总线上，和主存通信，单片机和本章节要讨论的就是这个。除此之外，还有具有通道结构的IO结构，具有IO处理机的结构，这两个也很重要，但是不讨论了。</p>
</li>
<li><p>IO组成<br>IO硬件的部分是大家都能具体接触的，但除了具体设备之外，还有接口模块，接口也是一些电路，主要功能是克服IO和主机之间的不匹配、不畅通、排队控制等困难的。<br>IO软件的功能就是将数据顺畅地在主机和IO设备之间流通，协调。而IO软件落到底层就是IO指令，它不同于一般的机器操作指令，由操作码、命令码、设备码构成。</p>
</li>
<li><p>IO和主机之间的联系方式<br>通常将IO设备码看成是地址码，通过设备编号来确定指令操作的是哪个设备。但是设备码的编制方法有统一编址和不统一编址两种。如果统一编址的话，那么就把设备地址和存储器地址放在一起，占用了内存，但是速度较快；如果不统一编址，则需要IO指令来操作一番，这样就降低了运行速度。<br>在IO和主机联系上之后，有立即响应的，也有通过IO接口联络响应的，这个叫做异步，也有同步响应的。</p>
</li>
<li><p>IO和主机之间的信息传送控制方法<br>在IO和主机联系之后，还有一些控制功能需要添加进去，所以，如何去控制信息传输有多种方法：<br>1、 程序查询：CPU发起的，不停地去监控IO设备有没有来；已经淘汰不用了。<br>2、 程序中断：单片机核心；等到IO发起中断请求的时候再处理。<br>3、 DMA：直接存取的方式，这种方法克服了当CPU响应中断的时候，无法进行计算的缺点。DMA只是挪用了一个周期而已，这个周期 叫做挪用周期。<br>4、 通道控制：略<br>5、 处理机控制：略</p>
</li>
<li><p>IO接口<br>设置接口是为了：1、实现IO选择；2、实现数据缓冲，解决CPU速度过高，IO速度太慢的问题；3、串并转换；4、调整为一致的电平；5、其他的一些控制功能。</p>
</li>
</ul>
<p>以上原文链接：<a href="https://blog.csdn.net/dongrixinyu/article/details/78608095">https://blog.csdn.net/dongrixinyu/article/details/78608095</a></p>
<h4 id="1-5-显卡"><a href="#1-5-显卡" class="headerlink" title="1.5 显卡"></a>1.5 显卡</h4><p>显卡又称<a href="https://baike.baidu.com/item/%E6%98%BE%E7%A4%BA%E5%8D%A1/103062">显示卡</a>( Video card)，是计算机中一个重要的组成部分，承担输出显示图形的任务，对喜欢玩游戏和从事专业图形设计的人来说，显卡非常重要。主流显卡的显示芯片主要由<a href="https://baike.baidu.com/item/NVIDIA/325313">NVIDIA</a>（英伟达）和<a href="https://baike.baidu.com/item/AMD/5905">AMD</a>（超威半导体）两大厂商制造，通常将采用NVIDIA显示芯片的显卡称为N卡，而将采用AMD显示芯片的显卡称为A卡。</p>
<p>配置较高的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>，都包含显卡计算核心。在科学计算中，显卡被称为显示加速卡。</p>
<p><a href="https://baike.baidu.com/item/%E6%98%BE%E7%A4%BA%E8%8A%AF%E7%89%87/206428">显示芯片</a>( Video chipset)是显卡的主要处理单元，因此又称为<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8/8694767">图形处理器</a>(Graphic Processing Unit，GPU)，GPU是NVIDIA公司在发布GeForce 256图形处理芯片时首先提出的概念。尤其是在处理3D图形时，<a href="https://baike.baidu.com/item/GPU/105524">GPU</a>使显卡减少了对CPU的依赖，并完成部分原本属于CPU的工作。GPU所采用的核心技术有硬件<a href="https://baike.baidu.com/item/T%26L/15272313">T&amp;L</a>（几何转换和光照处理）、立方环境材质贴图和顶点混合、纹理压缩和凹凸映射贴图、双重纹理四<a href="https://baike.baidu.com/item/%E5%83%8F%E7%B4%A0/95084">像素</a>256位<a href="https://baike.baidu.com/item/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/10982158">渲染引擎</a>等，而硬件T&amp;L技术可以说是GPU的标志。</p>
<p>显卡所支持的各种<a href="https://baike.baidu.com/item/3D%E7%89%B9%E6%95%88/11071016">3D特效</a>由<a href="https://baike.baidu.com/item/%E6%98%BE%E7%A4%BA%E8%8A%AF%E7%89%87/206428">显示芯片</a>的性能决定，采用什么样的显示芯片大致决定了这块显卡的档次和基本性能，比如<a href="https://baike.baidu.com/item/NVIDIA/325313">NVIDIA</a>的GT系列和<a href="https://baike.baidu.com/item/AMD/5905">AMD</a>的HD系列。</p>
<p>衡量一个显卡好坏的方法有很多，除了使用测试软件测试比较外，还有很多指标可供用户比较显卡的性能，影响显卡性能的高低主要有<a href="https://baike.baidu.com/item/%E6%98%BE%E5%8D%A1%E9%A2%91%E7%8E%87/9816288">显卡频率</a>、<a href="https://baike.baidu.com/item/%E6%98%BE%E7%A4%BA%E5%AD%98%E5%82%A8%E5%99%A8/3430768">显示存储器</a>等性能指标</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础系列-计算机如何执行指令</title>
    <url>/2022/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>计算机如何执行指令</p>
<span id="more"></span>
<p>学习来源：<a href="https://www.yuque.com/books/share/227872c0-1f19-4c83-960e-5e13e39343c8/fv71rh">https://www.yuque.com/books/share/227872c0-1f19-4c83-960e-5e13e39343c8/fv71rh</a></p>
<h2 id="一-计算机如何执行指令"><a href="#一-计算机如何执行指令" class="headerlink" title="一.计算机如何执行指令"></a>一.计算机如何执行指令</h2><h4 id="1-1-计算机指令"><a href="#1-1-计算机指令" class="headerlink" title="1.1 计算机指令"></a>1.1 计算机指令</h4><p>如果我们从软件工程师的角度来讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。<br>不同的 CPU 能够听懂的语言不太一样。比如，我们的个人电脑用的是 Intel 的 CPU，苹果手机用的是 ARM 的 CPU。这两者能听懂的语言就不太一样。类似这样两种 CPU 各自支持的语言，就是两组不同的计算机指令集，英文叫 Instruction Set。这里面的“Set”，其实就是数学上的集合，代表不同的单词、语法。</p>
<h4 id="1-2-CPU如何执行指令"><a href="#1-2-CPU如何执行指令" class="headerlink" title="1.2 CPU如何执行指令"></a>1.2 CPU如何执行指令</h4><p>下图展示了一般程序的运行流程（以 C 语言为例），可以说了解程序的运行流程是掌握程序运行机制的基础和前提。<br><img src="/images/cpuzl.png"><br>在这个流程中，CPU 负责的就是解释和运行最终转换成机器语言的内容。<br>CPU 是计算机的心脏和大脑，它和内存都是由许多晶体管组成的电子部件。它接收数据输入，执行指令并处理信息。它与输入/输出（I / O）设备进行通信，这些设备向 CPU 发送数据和从 CPU 接收数据。<br>从功能来看，CPU 的内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连通。</p>
<ul>
<li>寄存器是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20 – 100个寄存器。</li>
<li>控制器负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</li>
<li>运算器负责运算从内存中读入寄存器的数据</li>
<li>时钟负责发出 CPU 开始计时的时钟信号</li>
</ul>
<h4 id="1-3-CPU指令执行过程"><a href="#1-3-CPU指令执行过程" class="headerlink" title="1.3 CPU指令执行过程"></a>1.3 CPU指令执行过程</h4><p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。</p>
<ul>
<li>取指令阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址</li>
<li>指令译码阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。</li>
<li>执行指令阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。</li>
<li>访问取数阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</li>
<li>结果写回阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取。</li>
</ul>
<h4 id="1-4-内存"><a href="#1-4-内存" class="headerlink" title="1.4 内存"></a>1.4 内存</h4><p>CPU 和 内存就像是一堆不可分割的恋人一样，是无法拆散的一对儿，没有内存，CPU 无法执行程序指令，那么计算机也就失去了意义；只有内存，无法执行指令，那么计算机照样无法运行。</p>
<h5 id="1-4-1-内存组成"><a href="#1-4-1-内存组成" class="headerlink" title="1.4.1 内存组成"></a>1.4.1 内存组成</h5><p>内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器</p>
<ul>
<li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 丢失。</li>
<li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失。</li>
<li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据。</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础系列-计算机组成原理</title>
    <url>/2022/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>计算机发展由来</p>
<span id="more"></span>
<h2 id="一-早期的计算器"><a href="#一-早期的计算器" class="headerlink" title="一.早期的计算器"></a>一.早期的计算器</h2><h3 id="1-1-算盘"><a href="#1-1-算盘" class="headerlink" title="1.1 算盘"></a>1.1 算盘</h3><p>计算机没有出现之前，最早的计算工具是计算器。<br>西亚人发明，最早的算盘出现在公元前2700到2300左右的苏美文明。</p>
<h3 id="1-2-算筹"><a href="#1-2-算筹" class="headerlink" title="1.2 算筹"></a>1.2 算筹</h3><p>是第一种有进位的10进制记数法</p>
<h3 id="1-3-纳皮尔算筹"><a href="#1-3-纳皮尔算筹" class="headerlink" title="1.3 纳皮尔算筹"></a>1.3 纳皮尔算筹</h3><p>17世纪初，英国数学家纳皮尔发明的“纳皮尔算筹”，主要用来计算乘除法</p>
<h3 id="1-4-计算尺"><a href="#1-4-计算尺" class="headerlink" title="1.4 计算尺"></a>1.4 计算尺</h3><p>约翰.纳皮尔继续提出对数概念，直接引出另一种沿用至今的计算工具-计算尺</p>
<h2 id="二-机械计算机"><a href="#二-机械计算机" class="headerlink" title="二.机械计算机"></a>二.机械计算机</h2><h3 id="2-1-契克卡德的计算钟（1623年）"><a href="#2-1-契克卡德的计算钟（1623年）" class="headerlink" title="2.1 契克卡德的计算钟（1623年）"></a>2.1 契克卡德的计算钟（1623年）</h3><p>1623年，德国科学家契克卡德制造了人类有史以来的第一台机械式计算机，这台计算机能够进行六位数的加减乘除，比帕斯卡机诞生早约了20年。</p>
<h3 id="2-2-帕斯卡计算器（1642年）"><a href="#2-2-帕斯卡计算器（1642年）" class="headerlink" title="2.2 帕斯卡计算器（1642年）"></a>2.2 帕斯卡计算器（1642年）</h3><p>1642年，法国数学家，物理学家和化学家帕斯卡借钟表指针的齿轮转动（天然的具有进位功能）发明了一台“帕斯卡计算器”。跟之前的计算器相比，虽然功能不及算筹个算盘，却是一次彻底的革命–算筹和算盘本身不包含算法，只能存储计算的中间结果，操作依赖熟记指令的人，本质上是寄存器。帕斯卡计算器却用内部的齿轮机构预存的算法，操作者完全不需要计算方法就能操作。</p>
<h3 id="2-3-莱布尼兹步进计算器（1674年）"><a href="#2-3-莱布尼兹步进计算器（1674年）" class="headerlink" title="2.3 莱布尼兹步进计算器（1674年）"></a>2.3 莱布尼兹步进计算器（1674年）</h3><p>德国大数学家，哲学家莱布尼兹在1672年到1694年之间发明的一种“步进计算器”，采用他独创的“莱布尼兹轮”，可以控制齿轮只转动需要的角度。这产生相当复杂的运算能力，除了普通的加减法以外，还能将两个八位数字相乘为一个十六位数字，或者用一个十六位数字的数字乘以一个八位数字。</p>
<h2 id="三-现代计算机鼻祖-查尔斯-巴贝奇"><a href="#三-现代计算机鼻祖-查尔斯-巴贝奇" class="headerlink" title="三.现代计算机鼻祖-查尔斯.巴贝奇"></a>三.现代计算机鼻祖-查尔斯.巴贝奇</h2><h3 id="3-1-差分思想"><a href="#3-1-差分思想" class="headerlink" title="3.1 差分思想"></a>3.1 差分思想</h3><p>帕斯卡1654年提出差分思想-n次多项式的n次数值差分为同一常数。</p>
<h3 id="3-2-差分机"><a href="#3-2-差分机" class="headerlink" title="3.2 差分机"></a>3.2 差分机</h3><p>1822年6月14日，查尔斯.巴贝奇向皇家天文学会递交了一篇《论机械在天文及数学用表计算中的应用》的论文，差分机的概念正式问世。</p>
<h3 id="3-3-分析机"><a href="#3-3-分析机" class="headerlink" title="3.3 分析机"></a>3.3 分析机</h3><p>之前差分机夭折了，1833年巴贝奇在此设计稿上不断改进直至离世，这台被他称为分析机的机械，直接将机械运算的理念从地表推上云天。<br>第一位程序员–艾达.洛夫莱斯</p>
<h3 id="3-4-穿孔制表机"><a href="#3-4-穿孔制表机" class="headerlink" title="3.4 穿孔制表机"></a>3.4 穿孔制表机</h3><p>穿孔卡是早期计算机输入信息的设备，通常可以储存80列数据。它是一种很薄的纸片，面积为190×84毫米。首次使用穿孔卡技术的数据处理机器，是美国统计专家霍列瑞斯博士（H.Hollerith）的伟大发明。Hollerith机(Hollerith Machine)，是美国人口普查催生的计算器。1880年以前，美国的人口普查都是人工做的。1880的普查完成之后，美国人意识到按照当时的人口增长速度，下一次1890年的普查十年也不可能完成统计，而美国的法律规定必须在十年内完成。于是招标寻找解决办法。Herman Hollerith设计了这种在纸板上打孔(punched card)的技术，帮助解决了统计局的难题。但是他本人并没有赚到钱。1896年他成立了一个公司(TabulatingMachine Company)，向其它国家卖他的产品。后来在他老了以后，他把公司卖给了手下的一个主管。最后成了成立IBM的三家公司之一。<br>霍列瑞斯首先把穿孔纸带改造成穿孔卡片，以适应人口数据采集的需要。由于每个人的调查数据有若干不同的项目，如性别、籍贯、年龄等等。霍列瑞斯把每个人所有的调查项目依次排列于一张卡片，然后根据调查结果在相应项目的位置上打孔。例如，穿孔卡片“性别”栏目下，有“男”和“女”两个选项；“年龄”栏目下有从“0岁”到“70岁以上”等系列选项，如此等等。统计员可以根据每个调查对象的具体情况，分别在穿孔卡片各栏目相应位置打出小孔。每张卡片都代表着一位公民的个人档案。<br>霍列瑞斯博士巧妙的设计在于自动统计。他在机器上安装了一组盛满水银的小杯，穿好孔的卡片就放置在这些水银杯上。卡片上方有几排精心调好的探针，探针连接在电路的一端，水银杯则连接于电路的另一端。与杰卡德提花机穿孔纸带的原理类似：只要某根探针撞到卡片上有孔的位置，便会自动跌落下去，与水银接触接通电流，启动计数装置前进一个刻度。由此可见，霍列瑞斯穿孔卡表达的也是二进制信息：有孔处能接通电路计数，代表该调查项目为“有”（“1”），无孔处不能接通电路计数，表示该调查项目为“无”（“0”）。<br>直到1888年，霍列瑞斯博士才实际完成自动制表机设计并申报了专利。他发明的这种机电式计数装置，比传统纯机械装置更加灵敏，因而被1890年后历次美国人口普查选用，获得了巨大的成功。例如，1900年进行的人口普查全部采用霍列瑞斯制表机，平均每台机器可代替500人工作，全国的数据统计仅用了1年多时间。虽然霍列瑞斯发明的并不是通用计算机，除了能统计数据表格外，它几乎没有别的什么用途，然而，制表机穿孔卡第一次把数据转变成二进制信息。在以后的计算机系统里，用穿孔卡片输入数据的方法一直沿用到20世纪70年代，数据处理也发展成为电脑的主要功能之一。</p>
<h2 id="四-图灵机-计算机世界的理论基石"><a href="#四-图灵机-计算机世界的理论基石" class="headerlink" title="四. 图灵机-计算机世界的理论基石"></a>四. 图灵机-计算机世界的理论基石</h2><p>图灵机，又称图灵计算机指一个抽象的机器，是，英国数学家艾伦・麦席森・图灵(1912―-1954年)于1936年提出的一种抽象的计算模型，即将人们使用纸笔进行数学运算的过程进行抽象，由一个虚拟的机器替代人类进行数学运算。<br>图灵提出图灵机的模型并不是为了同时给出计算机的设计，它的意义有如下几点:<br>(1)它证明了通用计算理论，肯定了计算机实现的可能性，同时它给出了计算机应有的主要架构；<br>(2)图灵机模型引入了读写与算法与程序语言的概念，极大的突破了过去的计算机器的设计理念；<br>(3)图灵机模型理论是计算学科最核心的理论，因为计算机的极限计算能力就是通用图灵机的计算能力，很多问题可以转化到图灵机这个简单的模型来考虑。<br>通用图灵机向人们展示这样一个过程:程序和其输入可以先保存到存储带上，图灵机就按程序一步一步运行直到给出结果，结果也保存在存储带上。更重要的是，隐约可以看到现代计算机主要构成，尤其是冯・诺依曼理论的主要构成。<br>从图灵开始，计算机有了真正坚实的理论基础，更多人开始投身计算机的理论研究，而不是尝试构建一台机器，从如今的应用来看，图灵机之于计算机领域的价值远高于数学领域，计算机的原始公式，只有图灵机这一个。1966年，美国计算机协会ACM设立计算机领域最高奖项，命名为图灵，图灵奖素有“计算机界的诺贝尔奖”之称，图灵的名字当之无愧。</p>
<h2 id="五-ENIAC（1945）"><a href="#五-ENIAC（1945）" class="headerlink" title="五.ENIAC（1945）"></a>五.ENIAC（1945）</h2><p>第一台电子通用计算机<br>ENIAC，全称为Electronic Numerical Integrator And Computer，即电子数字积分计算机。ENIAC是继ABC（阿塔纳索夫-贝瑞计算机）之后的第二台电子计算机和第一台通用计算机。<br>它是完全的电子计算机，能够重新编程，解决各种计算问题。它于1946年2月14日在美国宣告诞生。 承担开发任务的人员由科学家约翰·冯·诺依曼和“莫尔小组”的工程师埃克特、莫克利、戈尔斯坦以及华人科学家朱传榘组成。总工程师埃克特在当时年仅25岁。</p>
<h2 id="六-冯诺依曼结构-现代计算机诞生"><a href="#六-冯诺依曼结构-现代计算机诞生" class="headerlink" title="六.冯诺依曼结构-现代计算机诞生"></a>六.冯诺依曼结构-现代计算机诞生</h2><p>美籍匈牙利数学家冯·诺依曼于1946年提出存储程序原理，把程序本身当作数据来对待，程序和该程序处理的数据用同样的方式储存。 冯·诺依曼体系结构冯·诺依曼理论的要点是：计算机的数制采用二进制；计算机应该按照程序顺序执行。<br>冯·诺伊曼体系结构是现代计算机的基础，现在大多计算机仍是冯·诺伊曼计算机的组织结构，只是作了一些改进而已，并没有从根本上突破冯体系结构的束缚。冯·诺伊曼也因此被人们称为“计算机之父”。然而由于传统冯·诺伊曼计算机体系结构天然所具有的局限性，从根本上限制了计算机的发展。<br><img src="/images/jsjyjxt.png"></p>
<h2 id="七-第二代电子计算机"><a href="#七-第二代电子计算机" class="headerlink" title="七.第二代电子计算机"></a>七.第二代电子计算机</h2><p>第二代电子计算机采用晶体管制造的电子计算机。国外第二代电子计算机的生存期大约是1957-1964年。其软件开始使用面向过程的程序设计语言，如fortran、algol等。中国第一台晶体管计算机于1967年制成，运算速度为每秒五万次。<br>第二代电子计算机是用晶体管制造的计算机。在20世纪50年代之前，计算机都采用电子管作元件。电子管元件有许多明显的缺点。例如，在运行时产生的热量太多，可靠性较差，运算速度不快，价格昂贵，体积庞大，这些都使计算机发展受到限制。于是，晶体管开始被用来作计算机的元件。使用了晶体管以后，电子线路的结构大大改观，制造高速电子计算机的设想也就更容易实现了。<br>1954年，美国贝尔实验室研制成功第一台使用晶体管线路的计算机，取名“催迪克”（TRADIC），装有800个晶体管。1955年，美国在阿塔拉斯洲际导弹上装备了以晶体管为主要元件的小型计算机。以后，在美国生产的同一型号的导弹中，由于改用集成电路元件，重量只有原来的1/100，体积与功耗减少到原来的1/300。1958年，美国的IBM公司制成了第一台全部使用晶体管的计算机RCA501型。由于第二代计算机采用晶体管逻辑元件，及快速磁芯存储器，计算机速度从每秒几千次提高到几十万次，主存储器的存贮量，从几千提高到10万以上。1959年，IBM公司又生产出全部晶体管化的的电子计算机IBM7090。1958-1964年，晶体管电子计算机经历了大范围的发展过程。从印刷电路板到单元电路和随机存储器，从运算理论到程序设计语言，不断的革新使晶体管电子计算机日臻完善。1961年，世界上最大的晶体管电子计算机ATLAS安装完毕。1964年，中国制成了第一台全晶体管电子计算机441-B型。</p>
<h2 id="八-第三代集成电路计算机"><a href="#八-第三代集成电路计算机" class="headerlink" title="八.第三代集成电路计算机"></a>八.第三代集成电路计算机</h2><p>第三代计算机即第三代集成电路计算机 (1964-1971)。特征是以中小规模集成电路（每片上集成一千个逻辑门以内）（西文写作SSI、MSI）来构成计算机的主要功能部件；主存储器采用半导体存储器。运算速度可达每秒几十万次至几百万次基本运算。在软件方面，操作系统日趋完善。</p>
<table>
<thead>
<tr>
<th align="left">发展阶段</th>
<th>逻辑元件</th>
<th>主存储器</th>
<th>运算速度（每秒）</th>
<th>软件</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一代（1946-1958）</td>
<td>电子管</td>
<td>电子射线管</td>
<td>几千次到几万次</td>
<td>机器语言、汇编语言</td>
<td>军事研究、科学计算</td>
</tr>
<tr>
<td align="left">第二代（1958-1964）</td>
<td>晶体管</td>
<td>磁芯</td>
<td>几十万次</td>
<td>监控程序、高级语言</td>
<td>数据处理、事务处理</td>
</tr>
<tr>
<td align="left">第三代（1964-1971）</td>
<td>中小规模集成电路</td>
<td>半导体</td>
<td>几十万次到几百万次</td>
<td>操作系统、编辑系统、应用程序</td>
<td>有较大发展开始广泛应用</td>
</tr>
<tr>
<td align="left">第四代（1971-至今）</td>
<td>大规模超大规模集成电路</td>
<td>集成度更高的半导体</td>
<td>上千万次到上亿次</td>
<td>操作系统完善、数据库系统、高级语言发展、应用程序发展</td>
<td>渗入社会各级领域</td>
</tr>
</tbody></table>
<h2 id="九-第四代大规模集成电路计算机（1971-至今）"><a href="#九-第四代大规模集成电路计算机（1971-至今）" class="headerlink" title="九.第四代大规模集成电路计算机（1971-至今）"></a>九.第四代大规模集成电路计算机（1971-至今）</h2><p> 随着大规模集成电路的发展，计算机进入了第四代发展。第四代计算机以大规模集成电路作为逻辑元件和存储器，使计算机向着微型化和巨型化两个方向发展。从第一代到第四代，计算机的<a href="https://so.csdn.net/so/search?q=%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">体系结构</a>都是相同的，即都由控制器，存储器，运算器和输入输出设备组成，称为冯·诺依曼体系结构 。 </p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小知识一</title>
    <url>/2022/02/21/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
    <content><![CDATA[<span id="more"></span>
<p>代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.study;</span><br><span class="line"></span><br><span class="line">public class TestThree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a=127,b=127;</span><br><span class="line">        Integer c=128,d=128;</span><br><span class="line">        System.out.println(<span class="string">&quot;a==b?&quot;</span>+(a==b));//<span class="literal">true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a==b?&quot;</span>+(c==d));//<span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Integer的cache是-128到127，可以改，jvm启动参数能改上限，不能改下限，可以看IntegerCache类，下线值是固定常量。<br><img src="/images/IntegerCache.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] data = &#123;4, 5, 3, 6, 2, 5, 1&#125;;</span><br><span class="line"> </span><br><span class="line">        // int[] 转 List&lt;Integer&gt;</span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.stream(data).boxed().collect(Collectors.toList());</span><br><span class="line">        // Arrays.stream(arr) 可以替换成IntStream.of(arr)。</span><br><span class="line">        // 1.使用Arrays.stream将int[]转换成IntStream。</span><br><span class="line">        // 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream&lt;Integer&gt;。</span><br><span class="line">        // 3.使用Stream的collect()，将Stream&lt;T&gt;转换成List&lt;T&gt;，因此正是List&lt;Integer&gt;。</span><br><span class="line"> </span><br><span class="line">        // int[] 转 Integer[]</span><br><span class="line">        Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::new);</span><br><span class="line">        // 前两步同上，此时是Stream&lt;Integer&gt;。</span><br><span class="line">        // 然后使用Stream的toArray，传入IntFunction&lt;A[]&gt; generator。</span><br><span class="line">        // 这样就可以返回Integer数组。</span><br><span class="line">        // 不然默认是Object[]。</span><br><span class="line"> </span><br><span class="line">        // List&lt;Integer&gt; 转 Integer[]</span><br><span class="line">        Integer[] integers2 = list1.toArray(new Integer[0]);</span><br><span class="line">        //  调用toArray。传入参数T[] a。这种用法是目前推荐的。</span><br><span class="line">        // List&lt;String&gt;转String[]也同理。</span><br><span class="line"> </span><br><span class="line">        // List&lt;Integer&gt; 转 int[]</span><br><span class="line">        int[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        // 想要转换成int[]类型，就得先转成IntStream。</span><br><span class="line">        // 这里就通过mapToInt()把Stream&lt;Integer&gt;调用Integer::valueOf来转成IntStream</span><br><span class="line">        // 而IntStream中默认toArray()转成int[]。</span><br><span class="line"> </span><br><span class="line">        // Integer[] 转 int[]</span><br><span class="line">        int[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        // 思路同上。先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream。</span><br><span class="line"> </span><br><span class="line">        // Integer[] 转 List&lt;Integer&gt;</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(integers1);</span><br><span class="line">        // 最简单的方式。String[]转List&lt;String&gt;也同理。</span><br><span class="line"> </span><br><span class="line">        // 同理</span><br><span class="line">        String[] strings1 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        // String[] 转 List&lt;String&gt;</span><br><span class="line">        List&lt;String&gt; list3 = Arrays.asList(strings1);</span><br><span class="line">        // List&lt;String&gt; 转 String[]</span><br><span class="line">        String[] strings2 = list3.toArray(new String[0]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在排序数组中查找元素的第一个和最后一个位置<br>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。<br>示例 1：<br>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]<br>示例 2：<br>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]<br>示例 3：<br>输入：nums = [], target = 0<br>输出：[-1,-1]</p>
<p>思路：首先看到题目说的排好序的数组，然后再根据给定的值去查找元素中对应的下标，想到了Arrays类中的binarySearch方法来直接拿值，它也是要一个排好序（而且是升序）的数组，应该可以很快实现，但是发现这个方法有坑，看下面例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] one=&#123;1,2,10,5,4,8,7,6&#125;;</span><br><span class="line">    int[] two=&#123;1,2,4,5,7,7,7,9&#125;;</span><br><span class="line">    //对数组先排序</span><br><span class="line">    Arrays.sort(one);</span><br><span class="line">    System.out.println(Arrays.toString(one));</span><br><span class="line">    int findOne=Arrays.binarySearch(one,7);</span><br><span class="line">    int findTwo=Arrays.binarySearch(two,7);</span><br><span class="line">    System.out.println(<span class="string">&quot;[1, 2, 4, 5, 6, 7, 8, 10]查找7的下标位置：&quot;</span>+findOne);</span><br><span class="line">    System.out.println(<span class="string">&quot;&#123;1,2,4,5,7,7,7,9&#125;查找7的下标位置：&quot;</span>+findTwo);</span><br><span class="line">    int findThree=Arrays.binarySearch(two,findTwo,two.length-1,7);</span><br><span class="line">    System.out.println(<span class="string">&quot;&#123;1,2,4,5,7,7,7,9&#125;从下标5到7这里找数字7：&quot;</span>+findThree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：<br>[1, 2, 4, 5, 6, 7, 8, 10]查找7的下标位置：5<br>{1,2,4,5,7,7,7,9}查找7的下标位置：5<br>{1,2,4,5,7,7,7,9}从下标5到7这里找数字7：5<br>//findOne没问题，第二次查找这里出问题了，{1,2,4,5,7,7,7,9}，出现7的位置下标是4，5，6这里，但是结果是5，findThree的结果也不对，<br>// 下标5到7之间下标6是7，显示结果却是下标5<br>//本想着用binarySearch(int[] a, int fromIndex, int toIndex, int key)实现查找下一个7，发现也不行。<br>// java官方也对这个方法有说明，使用二进制搜索算法在指定的整数数组中搜索指定的值。在进行此调用之前，必须对数组进行排序（就像使用{@link#sort（int[]）}方法一样）。如果不排序，则结果未定义。如果数组包含多个具有指定值的元素，则无法保证将找到哪一个元素。也就是说如果数值中有多个重复的值，它可能就无法正确定位到该位置<br>binarySeach.png</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static int binarySearch(int[] a, int key) &#123;</span><br><span class="line">        <span class="built_in">return</span> binarySearch0(a, 0, a.length, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int binarySearch(int[] a, int fromIndex, int toIndex,int key) &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="built_in">return</span> binarySearch0(a, fromIndex, toIndex, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Like public version, but without range checks.</span><br><span class="line">    private static int binarySearch0(int[] a, int fromIndex, int toIndex,int key) &#123;</span><br><span class="line">        int low = fromIndex;</span><br><span class="line">        int high = toIndex - 1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">            int midVal = a[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">                low = mid + 1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">return</span> mid; // key found</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> -(low + 1);  // key not found.</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到调用Arrays.binarySearch()方法实际上就是调用binarySearch0()方法，binarySearch0（）方法其实是一个二分查找法，这就是为什么我们使用Arrays.binarySearch()前需要进行排序，以及多个数值相同的数，无法精确定位下标的原因。</p>
<p>所以我们接下来的思路是参照官方的方法自己写个binarySearch二分查找来解决这个问题，将查找值与数组最中间值比较,若查找值相等数字最中间值就找到了,返回下标值;若查找值小于最中间值,则把最左边到中间作为一个数组再进行查找;若查找值大于最中间值,则把中间到最右边作为一个数组再进行查找.</p>
<p>我们先看平时效率快的解法,时间复杂度为O(n)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int[] location=&#123;-1,-1&#125;;</span><br><span class="line">        //标记出现次数</span><br><span class="line">        boolean flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(int a=0;a&lt;nums.length;a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[a] == target) &#123;</span><br><span class="line">                //第一次出现位置</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    location[0] = a;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    location[1] = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> location;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用二分查找时间时间复杂度为O(logn)，别看上面的代码少，但是当我们这个数组非常大的时候，性能就这个快了！<br>为什么使用&gt;&gt;&gt;（无符号位右移），而不是用&gt;&gt;（右移）这是避免数据过大，导致溢出为什么使用&gt;&gt;&gt;位运算符，而不是直接除以2，这是因为&gt;&gt;&gt;可以提高编程的运行速度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static int[] binarySearch(int[] arr, int left, int right, int findValue) &#123;</span><br><span class="line">        //当left&gt;right时，说明递归整个数组，左边值的下标大于最右边的下标,即代表查找完毕,没有找到该值,返回[-1,-1]</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            int[] result=&#123;-1,-1&#125;;</span><br><span class="line">            <span class="built_in">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right)&gt;&gt;&gt;1;</span><br><span class="line">        int midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findValue &gt; midVal) &#123;//向右递归</span><br><span class="line">            <span class="built_in">return</span> binarySearch(arr, mid + 1, right, findValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findValue &lt; midVal) &#123;//向左递归</span><br><span class="line">            <span class="built_in">return</span> binarySearch(arr, left, mid - 1, findValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int[] result=&#123;-1,-1&#125;;</span><br><span class="line">            int temp =0;</span><br><span class="line">            //向mid索引值得左边扫描，将所有满足findValue，的元素的下标，加入到集合中ArrayList</span><br><span class="line">            temp = mid - 1;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; 0 || arr[temp] != findValue) &#123;//退出</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //否则，就把temp放入到集合中</span><br><span class="line">                result[0]=temp;</span><br><span class="line">                temp--;//temp左移</span><br><span class="line">            &#125;</span><br><span class="line">            result[1]=mid;</span><br><span class="line">            //向mid索引值得右边扫描，将所有满足findValue，的元素的下标，加入到集合中ArrayList</span><br><span class="line">            temp = mid + 1;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; arr.length - 1 || arr[temp] != findValue) &#123;//退出</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //否则，就把temp放入到集合中</span><br><span class="line">                result[1]=temp;</span><br><span class="line">                temp++;//temp左移</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
